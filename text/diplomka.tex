\documentclass{ctuthesis}

    \usepackage[T1]{fontenc}
    \usepackage[utf8]{inputenc}
    \usepackage{amsmath,amssymb,amsfonts,amsthm}
    \usepackage{indentfirst}
    \usepackage{graphicx}
    \usepackage[boxed]{algorithm2e}
    \SetKwArray{Marker}{marker}

    \usepackage{tikz}
    \usepackage{caption,lipsum}
    \usepackage{listings}
    \usepackage{mathtools}
    \usepackage{multirow}
    \usepackage{url}
    \usepackage{longtable}
    \usetikzlibrary{calc}
    \setcounter{secnumdepth}{3}

    \usepackage{pifont}% http://ctan.org/pkg/pifont
    \newcommand{\cmark}{\ding{51}}%
    \newcommand{\xmark}{\ding{55}}%

\theoremstyle{plain}
    \newtheorem{theorem}{Věta}
    \newtheorem{lemma}{Lemma}
    \newtheorem{proposition}{Tvrzení}
    \newtheorem*{corollary}{Důsledek}
\theoremstyle{definition}
    \newtheorem{definition}{Definice}
    \newtheorem{remark}{Poznámka}
    \newtheorem{example}{Příklad}
    \newtheorem{observation}{Pozorování}
\renewcommand*{\proofname}{Důkaz}

\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}\PackageWarning{TODO:}{TODO: #1!}}
%\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}


\ctusetup{
  author = {Bc. Vladislav Matúš},
  supervisor = {prof. Ing. Miroslav Tůma, CSc.},supervisor-address = {Charles University in Prague, Faculty of Mathematics and Physics, Sokolovská 83, 186 75, Praha 8},
  titlelanguage = czech,
  mainlanguage = czech,
  year = 2018,
  month = 12,
  title-english = {Graph repartitioning based on sparse matrix factorization techniques},
  title-czech = {Přerozdělení oblastí v grafu založené na technikách rozkladu řídkých matic},
  xdoctype = M,
  xfaculty = F4,
  front-specification=true,
  specification-file={zadani.pdf},
  department-czech = {Katedra Matematiky},
  keywords-czech = {Dělení grafů, Grafové algoritmy, Řídké matice, Choleského rozklad, Číslování grafu, Eliminační stromy},
  keywords-english = {Graph partitioning, Graph algorithms, Sparse matrices, Cholesky decomposition, Graph numbering, Elimination trees},
  fieldofstudy-czech = {Matematická informatika},
  fieldofstudy-english = {Mathematical informatics},
}

\ctuprocess


\begin{abstract-czech}
  Choleského rozklad je často používanou metodou pro řešení soustav lineárních rovnic se symetrickou  a pozitivně definitní maticí. Jeho hledání lze paralelizovat pomocí algoritmů dělení grafů. Při použití standardních postupů však narážíme na problém nevyváženosti počtu nenulových prvků v Choleského faktorech podmatic jednotlivých oddělených oblastí. V této práci analyzujeme metody, jak globálně snížit počet nenulových prvků v Choleského faktoru pomocí číslování příslušného grafu a jak aposteriorně modifikovat rozdělení grafu tak, aby Choleského faktory podmatic odpovídajících těmto odděleným oblastem obsahovaly co nejpodobnější počet nenulových prvků.
\end{abstract-czech}

\begin{declaration}
  Prohlašuji, že jsem tuto práci vypracoval samostatně a uvedl jsem všechnu použitou literaturu.

  \medskip
  V Praze dne 9. prosince 2018
\end{declaration}

\begin{thanks}
  Rád bych poděkoval především svému školiteli prof.~Ing.~Miroslavu Tůmovi, CSc., za jeho ochotu, pečlivost, vstřícnost a odborné i lidské zázemí při vedení mé diplomové práce.
\end{thanks}

\begin{abstract-english}
  Cholesky decomposition is a well-known and popular scheme for solving linear systems with symmetric and positive definite matrices. It can be parallelized by using graph partitioning algorithms. However, using standard criteria of graph partitioning may be insufficient, as they do not cover the imbalance in number of nonzeros in Cholesky factors of of resulting separated subgraphs. In this thesis we analyze the methods for numbering the vertices of the graph and thereby reducing the number of nonzeros in the Cholesky factors of the subgraphs. We modify the graph partition using a posteriori approach and elucidate its impact on the balance of number of nonzeros in Cholesky factors.
\end{abstract-english}


\begin{document}
\TODO{oneside?}
\TODO{tahle sablona, nebo jina?}
\TODO{udelat poradek s tabulkama}

\maketitle

\chapter*{Úvod}

V této diplomové práci se budeme zabývat využitím dělení grafů jakožto nástroje pro paralelizaci Choleského rozkladu řídké matice. Nejprve ukážeme, že základní kritéria pro dělení grafů nepokrývají počet nenulových prvků v Choleského rozkladu matic sousednosti jednotlivých podgrafů. Dále z analytického hlediska prozkoumáme vliv číslování vrcholů grafu na počet nenulových prvků v Choleského rozkladu matice.  Poté se pomocí aposteriorního přístupu úpravy rozdělení grafu pokusíme analyzovat, zda je možné jednoduchým způsobem vylepšit rozdělení grafu tak, aby byl počet nenulových prvků v Choleského faktorech na jednotlivých oblastech vyvážený.

Tato diplomová práce je strukturována následovně. V první kapitole je zaveden pojem grafu a s ním související základní pojmy. Dále je zavedena speciální třída grafů nazývaných stromy. Také jsou nastíněny možné reprezentace matice pomocí grafu a grafu pomocí matice, které hrají v této práci klíčovou roli.
Ve druhé kapitole popisujeme problém dělení grafu s ohledem na základní kritéria a zavádíme základní pojmy s ním spojené. Dále popisujeme metody pro dělení grafů s důrazem na víceúrovňové schéma dělení grafu. Vzhledem k povaze tohoto schématu uvádíme matematický popis Spektrálního dělení grafu jakožto algoritmu, který je běžně využíván jako jeho součást. Dále zmiňujeme algoritmus podle Kernighana a Lina, jakožto příklad vylepšovacího algoritmu, jehož modifikace jsou standardně využívány v zjemňovací fázi víceúrovňového dělení grafu. Na závěr kapitoly je popsána Metoda vnořených řezů jakožto příklad algoritmu, který je ze své podstaty zaveden jako víceúrovňový.
Třetí kapitola se věnuje rozkladům matic. V této kapitole jsou blíže popsáni dva zástupci úplných rozkladů, konkrétně Symetrická eliminace a Choleského rozklad jakožto její speciální případ. Pro Choleského rozklad je popsáno teoretické odvození tří metod pro jeho výpočet a vysloveny věty popisující vlastnosti Choleského rozkladu řídkých matic.
Ve čtvrté kapitole blíže popisujeme souvislost dělení grafů a výpočtu Choleského rozkladu matice. Je objasněn postup, jakým vypočítat Choleského rozklad matice, pokud známe Choleského rozklady jejích podmatic odpovídajících podgrafům vzniklým pomocí dělení grafu odpovídajícího vstupní matici. Dále se budeme zabývat algoritmy pro očíslování vrcholů grafu jakožto nástrojem pro snížení počtu nenulových prvků v Choleského rozkladu matice. Popíšeme dva základní způsoby číslování vrcholů grafu a dva způsoby založené na kombinaci předchozích. Dalším tématem, kterým se v této kapitole zabýváme jsou eliminační stromy. Ty lze využít pro rychlý výpočet počtu nenulových prvků v Choleského rozkladu matice bez znalosti konkrétních hodnot v tomto rozkladu. Obecně definujeme eliminační strom matice a vysvětlíme jeho vztah s Choleského rozkladem. Dále uvádíme algoritmus pro výpočet počtu nenulových prvků v Choleského rozkladu matice při znalosti tvaru eliminačního stromu a dva algoritmy pro tvorbu eliminačního stromu matice.
Pátá kapitola je zaměřena na popis implementace námi vytvořeného programu. Jsou zde popsány námi využité základní datové struktury a detailně vysvětleny metody implementace jednotlivých kroků programu. Na závěr kapitoly jsou popsány způsoby volání výsledného programu z příkazové řádky.
Šestá kapitola se již věnuje samotným výsledkům našeho programu. Popisujeme námi naměřenou závislost mezi číslováním vrcholů grafu a počtem nenulových prvků v Choleského faktoru odpovídající matice. Na základě dat konstatujeme, které metody číslování se ukázaly jako nejvhodnější. Ve druhé části kapitoly diskutujeme možnost vylepšování rozdělení grafu vzhledem k vyváženosti počtu nenulových prvků v Choleského rozkladu matice pomocí přesouvání vrcholového separátoru. Ukazujeme, že v mnoha případech lze vyváženost výrazně zlepšit, zároveň však poukazujeme na možné nedostatky tohoto postupu pro konkrétní typy matic. Na závěr kapitoly je demonstrován postup, jak jeden z těchto nedostatků eliminovat.



%----------------------------------------------------------------------

\chapter{Grafy, stromy}
V této kapitole definujeme graf jakožto matematickou strukturu, popíšeme základní pojmy týkající se grafů a nastíníme možné vztahy mezi grafem a maticí. Dále definujeme strom, jakožto speciální případ grafu. Terminologie je převzata z \cite{koub:11}

\section{Základní grafová terminologie}

\begin{definition}
  Mějme množinu $V$ a množinu $E = \left\{ \left\{ u,v \right\} | u,v \in V \right\}$. Uspořádanou dvojici $G := (V,E)$, nazveme neorientovaný graf. Množinu $V$ nazýváme množinou vrcholů grafu $G$ a jejím prvkům říkáme vrcholy. Množinu $E$ nazýváme množinou hran grafu $G$, jejím prvkům říkáme hrany. Prvky hrany $e$ označujeme jako vrcholy incidentní hraně $e$ nebo koncové body hrany $e$. Říkáme, že hrana $e = \{v,w\}$ spojuje vrcholy $v$ a $w$.
\end{definition}

Pokud neuvažujeme hrany jako nejvýše dvouprvkové množiny vrcholů, ale  jako uspořádané dvojice $(u,v)$, nazýváme odpovídající graf \textbf{orientovaný}. Obvykle uvažujeme orientované a neorientované grafy samostatně, ale je možné uvažovat i jejich kombinaci. Graf, v němž se vyskytují jak orientované tak neorientované hrany, nazýváme \textbf{smíšený}. Řekneme, že neorientovaný graf $G$ je \textbf{úplný}, pokud $\forall u, v \in V$ $\left(\{u,v\} \in E\right)$.

Povšimněme si, že v definici grafu není vyloučen případ, kdy jsou oba koncové body hrany shodné. Hrana je pak jednoprvkovou množinou a nazýváme ji \textbf{smyčkou} v grafu.

\begin{remark}
  V neorientovaném grafu $G=(V,E)$ platí, že jeho množina hran $E$ je podmnožinou ${V \choose 2} \cup V$, kde $V \choose 2$ značí množinu všech dvouprvkových podmnožin množiny $V$. V orientovaném grafu $H=(W,F)$ je $F$ podmnožinou množiny $W \times W \cup W$, tj. všech uspořádaných dvojic vrcholů z $W$ a orientovaných smyček.
\end{remark}

\textbf{Stupněm vrcholu} $v \in V$ rozumíme počet vrcholů spojených s vrcholem $v$ a značíme $d(v)$. Množinu všech vrcholů, které jsou v grafu $G$ spojeny s vrcholem $v$ značíme $\mathrm{adj}_G(v)$. Pokud je z kontextu jasné o jaký graf se jedná, dolní index vynecháváme.

\begin{definition}
  \textbf{Podgrafem} grafu $G$ nazveme libovolný graf $H=(W,F)$, který splňuje: $W\subseteq V$, $F\subseteq E$ a všechny vrcholy incidentní hranám z $F$ náleží do $W$. Úplný podgraf grafu $G$ nazýváme \textbf{klikou} v grafu $G$. Podgrafem grafu $G$ \textbf{indukovaným} množinou vrcholů $W$ nazveme takový podgraf $G$, který obsahuje všechny hrany grafu $G$, jejichž oba koncové body náleží do $W$ a značíme jej $G(W)$.
\end{definition}

\begin{definition}
  Mějme graf $G=(V,E)$ a zobrazení $\omega:V \rightarrow \mathbb{R}$, resp. $c: E \rightarrow \mathbb{R}$. Přidáním zobrazení $\omega$, resp. $c$, ke~grafu $G$ dostaneme graf, který nazýváme \textbf{ohodnocený}, resp. \textbf{vážený} reálným ohodnocením.
\end{definition}

\begin{definition}
  Mějme neorientovaný graf $G=(V,E)$ a nechť $k$ je přirozené číslo. Posloupnost vrcholů $(v_i)_{i=1}^{k}$ nazveme \textbf{sledem} v grafu $G$, pokud $\forall i \in \{1,...,k\} (\{v_{i-1},v_i\} \in E)$. Pokud navíc  $\forall i,j \in \{1,...,k\} (i \neq j \Rightarrow v_i \neq v_j)$, nazveme posloupnost $(v_i)_{i=1}^{k}$ \textbf{cestou}.
\end{definition}

Existuje-li mezi libovolnými dvěma vrcholy grafu cesta, řekneme, že graf je \textbf{souvislý}.
\textbf{Vzdáleností} dvou vrcholů v souvislém grafu $G=(V,E)$ nazveme délku nejkratší cesty mezi těmito dvěma vrcholy. Vzdáleností vrcholu $v \in V$ od množiny vrcholů $W \subset V$ nazveme minimální vzdálenost mezi vrcholem $v$ a libovolným vrcholem náležícím do $W$. 

\medskip

Při používání víceúrovňových metod dělení grafů (viz kapitola \ref{multilevel}) budeme často odvozovat z grafu jiný graf shluknutím množin jeho vrcholů. Takový graf budeme nazývat faktorgraf a formálně jej definujeme následovně.

\begin{definition}
  Nechť $n\in \mathbb{N}$ a $\mathcal{P} = \{P_1,\ldots,P_n\}$ je rozkladem množiny vrcholů $V$ grafu $G = (V, E)$ a $|V|=n$. Faktorgrafem grafu $G$ nazveme graf $G / \mathcal{P} = (\mathcal{P}, \mathcal{E_P})$, kde 
  \[
    \left(
      (P_i, P_j)\in \mathcal{E_P} \mbox{ pro } i,j \in \{1,\ldots,n\}, i \neq j 
    \right)
    \Leftrightarrow {P_i \cap \mathrm{adj}_G(P_j) \neq \emptyset}
    .
  \]
\end{definition}

Proces vytváření faktorgrafu $G / \mathcal{P}$ z grafu $G$ je znázorněn na obrázku \ref{faktorgrafImg}

\bigskip
{
  \centering
  \includegraphics[width=0.8\textwidth]{pictures/faktorgrafcomplete.pdf}
  \captionof{figure}{Proces vytváření faktorgrafu \label{faktorgrafImg}}
}

\section{Strom}

Nyní zaveďme základní pojmy týkající speciální třídy grafů nazývané stromy \cite{koub:11}.

\begin{definition}
  \textbf{Stromem} $T=(V,E)$ nazveme konečný souvislý neorientovaný graf bez cyklů. Pokud navíc v grafu $T$ vyznačíme bod $r \in V$, nazýváme uspořádanou dvojici $(T,r)$ \textbf{kořenovým stromem} a bod $r$ nazveme kořenem tohoto stromu.
\end{definition}

Z definice stromu je patrné, že každý vrchol $v$ kořenového stromu $(T,r)$ spojuje s kořenem tohoto stromu právě jedna cesta.
Vrcholy ležící na této cestě nazveme \textbf{předchůdci} vrcholu $v$. Předchůdce vrcholu $v$ různé od $v$ nazýváme \textbf{vlastními předchůdci} vrcholu $v$. Vrcholy, jejichž předchůdcem je vrchol $v$, nazýváme \textbf{následníky} vrcholu $v$. Vrcholy bez následníků nazýváme \textbf{listy stromu} $T$, vrcholy alespoň s jedním následníkem nazýváme \textbf{vnitřní vrcholy} stromu $T$.

\begin{definition}
  \textbf{Podstromem} stromu $T$ určeným vrcholem $v$ nazveme podgraf stromu $T$ indukovaný vrcholem $v$ a všemi jeho následníky.
\end{definition}

\section{Vztah grafu a matice}
\label{GrMatRel}
Grafy a matice spolu úzce souvisí, což nám umožňuje převádět problémy na maticích na problémy na grafech a naopak. Nezanedbatelným praktickým důsledkem jejich vzájemného vztahu je i možnost používat grafové algoritmy při řešení některých maticových úloh. Především může být tento přístup výhodný pro řídké matice. Dělení grafů může posloužit například při snaze o paralelizaci rozkladu matice.

Uvažujme neorientovaný graf $G=(V,E)$ s vrcholy $V = \{v_1, \ldots, v_n\}$ a hranami $E = \{e_1, \ldots, e_m\}$. Tento graf lze reprezentovat pomocí matice dvěma základními způsoby. \textbf{Maticí sousednosti} grafu $G$, neboli adjacenční maticí, nazveme matici $A_G$ o rozměrech $n \times n$, jejíž prvek na pozici $(i,j)$ je definován jako:
\[
  {(A_G)}_{i,j} :=
  \left\{
    \begin{array}{@{\,}ll}
      1  & \mbox{existuje-li hrana spojující vrcholy $v_i, v_j$,} \\
      0  & \mbox{jinak.}
    \end{array}
  \right.
\]

 \textbf{Maticí incidence} grafu $G$ nazveme matici o rozměrech $n \times m$  definovanou následovně:
\[
  {(\bar{A}_G)}_{i,j} :=
  \left\{
	  \begin{array}{@{\,}ll}
		  1  & \mbox{je-li $v_i$ koncovým vrcholem hrany $e_j$,} \\
		  0  & \mbox{jinak.}
	  \end{array}
  \right.
\]

V kapitole \ref{spektral} budeme potřebovat \textbf{Laplaceovu matici} $Q$ grafu $G$. Jedná se o matici o rozměrech $n \times n$ definovanou následovně:
\[
Q_{ij} :=
\left\{
	\begin{array}{@{\,}ll}
		-1  & \mbox{pro } i \neq j, (v_i,v_j) \in E, \\
		0 & \mbox{pro } i \neq j, (v_i,v_j) \notin E,\\
        d(i) & \mbox{pro } i = j.
	\end{array}
\right.
\]
Laplaceovu matici $Q$ lze tedy vyjádřit jako $Q = D - A_G$, kde $D$  značí diagonální matici se stupni jednotlivých vrcholů na diagonále.

\medskip

Pokud chceme reprezentovat matici pomocí grafu, většinou nám stačí zachytit její strukturu. V takovém případě můžeme pro popis obecně nesymetrické matice $A$ o rozměrech $n \times n$ použít orientovaný graf s množinou vrcholů $V = \{v_1,\ldots,v_n\}$ a množinou hran $E =\left\{(v_i,v_j) \ | \ a_{ij}\neq 0\right\}$. V případě, že je matice $A$ symetrická, můžeme ji analogickým způsobem reprezentovat pomocí neorientovaného grafu.
Pokud bychom chtěli do grafu zanést i numerické hodnoty jednotlivých prvků matice, museli bychom použít ohodnocený graf.

\begin{remark}
  Pro jednoduchost zaveďme následující terminologii. Říkáme, že graf $G$ \textbf{odpovídá} matici $A$ právě tehdy, když matice $A$ má nenulové prvky na stejných pozicích jako matice sousednosti grafu $G$.
\end{remark}

\bigskip
{
  \centering
  \includegraphics[width=0.7\textwidth]{pictures/matgr.pdf}
  \captionof{figure}{Příklad grafu a jemu odpovídající struktury matice\label{prGrMat}}
}
\bigskip

Pro reprezentaci ne nutně čtvercové matice $A$ o rozměrech $m\times n$ můžeme také použít bipartitní graf, který je definován následovně:

\begin{definition}
  Graf $G=(V,E)$ nazveme bipartitním, pokud existuje rozklad množiny $V$ na podmnožiny $R$, $B$ takové, že ${R \choose 2} \cap E = {B \choose 2} \cap E = \emptyset$.
\end{definition}

Jinými slovy se jedná o graf, který lze rozdělit na dvě části tak, že v žádné z částí není ani jedna hrana. Takovýto bipartitní graf se standardně značí $G=(R,B,E)$ a pokud chceme s jeho pomocí reprezentovat matici $A$, pokládáme $|R|=m$, $|B|=n$ a $E = \left\{(v_i,v_j) \ | \ v_i \in R, v_j \in B, a_{ij} \neq 0 \right\}$. Příklad reprezentace struktury matice pomocí bipartitního grafu je znázorněn na obrázku \ref{bipartMat}.

\bigskip
{
  \centering
  \includegraphics[width=0.8\textwidth]{pictures/bipart_grmat.pdf}
  \captionof{figure}{Reprezentace struktury matice pomocí bipartitního grafu \label{bipartMat}}
}

%----------------------------------------------------------------------

\chapter{Dělení grafů}

V této kapitole formálně popíšeme problém dělení grafu na $k$ podgrafů a definujeme pojmy s ním spojené. Vzhledem k tomu, že v naší implementaci používáme pro dělení grafů profesionální softwarovou knihovnu METIS \cite{kary:13}, zaměříme se nejprve na schéma víceúrovňového dělení grafu jakožto algoritmus používaný při profesionálních implementacích dělení grafů. Dále se budeme věnovat některým technikám, které tvoří součást víceúrovňového dělení grafů, konkrétně spektrálnímu dělení grafu a vylepšovacímu algoritmu podle Kernighana a Lina \cite{keli:70}. Na závěr kapitoly zmíníme algoritmus metody vnořených řezů (Nested Dissection) jakožto příklad víceúrovňového algoritmu pro dělení grafů.

Dělení grafů na $k$ podgrafů je praktický problém s bohatým teoretickým zázemím a mnoha aplikacemi. Může nám pomoci při řešení parciálních diferenciálních rovnic na moderních počítačových architekturách \cite{posl:90} a nezanedbatelnou roli hraje také při výrobě mikroprocesorů metodou VLSI nebo při řešení velkých systémů lineárních rovnic \cite{keli:70, pis:84}. Často dochází k omezení se na dělení grafu na dva podgrafy, v této práce se však pokusíme prozkoumat i dělení grafu na více částí.

Podmínky, které jsou na výsledné rozdělení grafu kladeny, se mohou lišit v závislosti na daném použití. V této kapitole popíšeme klasická kritéria, která se používají pro určování kvality rozdělení grafu. V kapitole \ref{dalsiParametry} poté bude popsán problém dělení grafů s použitím dodatečných kritérií s důrazem na rozklady matic.

\section{Formální definice dělení grafu}

Jako dělení grafu na $k$ částí označujeme hledání rozkladu množiny vrcholů tohoto grafu na $k$ podmnožin. V nejklasičtějším případě je problém dělení grafů na $k$ podgrafů definován následovně.
\begin{definition}
  Mějme graf $G=(V,E)$, $|V| = n$. \textbf{Rozdělením grafu} $G$ na $k$ podgrafů $G_1, \ldots, G_k$ nazveme rozklad množiny vrcholů $V$ na vzájemně disjunktní podmnožiny $V_1, V_2, \ldots, V_k$, které indukují podgrafy $G_1, \ldots, G_k$.   
\end{definition}

\begin{remark}
  Rozdělení grafu běžně zapisujeme pomocí vektoru $P$ o délce $n$ takového, že pro každý vrchol $v_i \in V$ je index podgrafu, v němž se vrchol v nachází, určen $i$-tou složkou vektoru $P$.  
\end{remark}

Řekneme, že rozdělení je \textbf{optimální} vzhledem k základním kritériím, pokud splňuje:
\begin{enumerate}
  \item $\forall i \in \{1, \ldots, k \} \ |V_i|=n/k$.
  \item Počet hran spojujících vrcholy ležící v různých podmnožinách je minimální možný.
\end{enumerate}

Pokud má graf $G$ sudý počet vrcholů a rozdělíme ho na dvě části s množinami vrcholů $V_1, V_2$, které mají stejný počet prvků, nazveme toto rozdělení \textbf{bisekcí} a velikost hranového separátoru nazýváme \textbf{šířkou bisekce}.

Mějme graf $G=(V,E)$ a jeho rozdělení na $k$ podgrafů s množinami vrcholů $V_1, V_2, \ldots, V_k$. Množinu hran, jejichž jeden koncový bod náleží do $V_i$ a druhý do $V_j$ pro $i \neq j$ nazveme \textbf{hranovým separátorem}, značíme $\delta(V_1,\ldots,V_k)$. Jinou variantou je hledat rozdělení grafu pomocí vrcholového separátoru.
\textbf{Vrcholovým separátorem} $S_G$ grafu $G$ nazveme podmnožinu množiny vrcholů $V$ takovou, že odstraněním všech vrcholů náležících do $S_G$ z grafu $G$ dojde k jeho rozpadu na nejméně $k$ komponent odpovídajících jednotlivým částem rozdělení. Řešení problému optimální transformace mezi hranovým a vrcholovým separátorem, známe-li jeden z nich, můžeme naleznout v \cite{pofa:90}. To nám ale nic neříká o řešení problému nalezení optimálního hranového nebo vrcholového separátoru \cite{liu:89}.

Ukazuje se, že rozhodovací problém pro optimální rozdělení grafu, pokud je možné, je NP-úplný \cite{gajo:79}. Existují však algoritmy, které rozdělí graf v rozumném čase, přičemž kvalita jimi nalezeného rozdělení bude poměrně dobrá \cite{lita:79} vzhledem k povaze úlohy.

\section{Obecné schéma víceúrovňového dělení grafů}
\label{multilevel}

Víceúrovňové dělení grafů slouží k převedení problému dělení grafu s velkým počtem vrcholů na problém dělení grafu s počtem vrcholů výrazně menším. Tím může dojít k výraznému zkrácení času potřebného pro celkovou dobu běhu algoritmu \cite{kaku:98}, proto je tento postup využíván v profesionálních softwarových nástrojích pro dělení grafů \cite{lehe:95, hele:95}. Nejobecnější popis tohoto schématu sestává ze tří základních fází: zhrubovací fáze (coarsening phase), rozdělení vzniklého grafu a projekce tohoto rozdělení zpět na původní graf (refinement phase).

\paragraph{Zhrubovací fáze}
Základní myšlenkou zhrubovací fáze víceúrovňového schématu dělení grafů je vytvořit z původního grafu $G$ graf $G_m$ s menším počtem vrcholů. Jinými slovy jde o konstrukci posloupnosti grafů $(G_i)_0^m$ takové, že $G_0 := G$ a pro každé dva po sobě jdoucí členy této posloupnosti platí, že $G_{i+1}$ je faktorgrafem $G_i$ s menším počtem vrcholů. 

Pro konstrukci posloupnosti $(G_i)_0^m$ existuje několik možných postupů \cite{lehe:95,lehe:94}. Ve většině schémat pro tvorbu grafu s méně vrcholy jsou podmnožiny množiny vrcholů grafu $G_i$ spojovány v jeden vrchol, čímž vznikne hrubší graf $G_{i+1}$ splňující výše uvedené podmínky kladené na posloupnost $(G_i)_0^m$, který je formálně faktorgrafem. Při konstrukci členu $G_{i+1}$ z členu $G_i$ je pro udržení strukturálních informací o původním grafu nutné, abychom použili ohodnocený graf, kde ohodnocení vrcholů a hran při tvorbě faktorgrafu pokládáme pro každý vrchol (resp. hranu) roven součtu vah všech vrcholů (resp. hran) spojením kterých daný vrchol (resp. hrana) vznikl. 

\begin{definition}
  Mějme graf $G = (V, E)$. \textbf{Párováním} grafu $G$ nazveme podmnožinu množiny hran $E$, pro kterou platí, že žádné dvě hrany z této množiny nemají společný koncový bod. \textbf{Maximálním párováním} grafu $G$ nazveme párování grafu $G$ obsahující nejvyšší možný počet hran. Pokud je graf $G$ vážený reálným ohodnocením $c$, nazveme maximálním párováním grafu $G$ párování grafu $G$ takové, že součet vah hran, které jsou v tomto párování grafu obsaženy, je nejvyšší možný.
\end{definition}

Pro získání hrubšího grafu byly popsány dva hlavní postupy. První z nich je založen na nalezení vhodného párování a následném spojení každé dvojice vrcholů spojených hranou náležící do párování do jednoho \cite{edmo:65,lawl:76}. Aby došlo k rychlému zmenšení počtu vrcholů grafu, je vhodné volit maximální párování \cite{hele:95}. Druhý postup hledání vhodných množin vrcholů pro sloučení je založen na spojování skupin vrcholů, v nichž je vysoká hustota hran \cite{lehe:94}.

\paragraph{Dělení získaného grafu}
V této fázi dochází k rozdělení grafu $H$ libovolným algoritmem pro dělení grafů, například lze použít spektrální dělení popsané níže v kapitole \ref{spektral}. Pomocí tohoto algoritmu získáme rozdělení $P_m$ grafu $G_m$.

Tato fáze víceúrovňového dělení grafu může být vynechána \cite{kaku:95}. V takovém případě ve zhrubovací fázi víceúrovňového dělení pokračujeme až do té doby než má výsledný graf $G_m$ počet vrcholů roven počtu částí, na které chceme graf $G$ rozdělit. Každý z vrcholů grafu $G_m$ pak přiřadíme do jiné části rozdělení $P_m$ a můžeme přímo přistoupit k projekci tohoto rozdělení na původní graf.

\paragraph{Projekce rozdělení na původní graf}
Cílem této fáze je převést získané rozdělení $P_m$ grafu $G_m$ na rozdělení $P_0$ vstupního grafu $G$. Toho dosáhneme postupnou tvorbou posloupnosti rozdělení $P_{m-1}, \ldots, P_1$ grafů $G_{m-1}, \ldots, G_1$. Nejjednodušším způsobem projekce rozdělení grafu $G_{i+1}$ na rozdělení grafu $G_i$ je umístit všechny vrcholy grafu $G_i$, jejichž spojením vznikl vrchol $v$ grafu $G_{i+1}$ do části rozdělení, v níž leží vrchol $v$.

Tento postup však není optimální, protože graf $G_i$ má větší počet vrcholů než $G_{i+1}$ a má tedy více stupňů volnosti vzhledem k optimalitě rozdělení. Díky tomu může nastat situace, kdy rozdělení $P_i$ získané z rozdělení $P_{i+1}$ lze dále vylepšit. Nejběžněji využívaným algoritmem pro vylepšování rozdělení grafu je algoritmus podle Kernighana a Lina \cite{keli:70}, který bude popsán v kapitole \ref{KLalgorithm}. Kvůli snížení časové náročnosti aplikace tohoto algoritmu se častěji setkáme s jeho aplikací pouze na části jednotlivých podgrafů ležící v blízkosti hranového či vrcholového separátoru než s jeho aplikací na celý graf \cite{kaku:98}.

\section{Spektrální dělení}
\label{spektral}

Spektrální algoritmus je jedním ze základních algoritmů řešících bisekci grafu. Rozdělení grafu nalezená spektrálním algoritmem bývají dobrá, ale jeho cena je poměrně vysoká. Z tohoto důvodu je pro velké grafy používán jako součást víceúrovňového dělení grafu, kde slouží k nalezení rozdělení hrubého grafu (viz kapitola \ref{multilevel}).

Mějme graf $G=(V,E)$ se sudým počtem vrcholů a řešme problém bisekce tohoto grafu na dva podgrafy $G_1=(V_1,E_1)$ a $G_2=(V_2,E_2)$. Základní myšlenkou spektrálního dělení je převést tento problém na problém minimalizace kvadratické formy.
Definujme vektor $\vec{x}$ délky $n:=|V_1|=|V_2|$ po složkách následovně:
\[
x_i =
\left\{
	\begin{array}{@{\,}ll}
		1  & \mbox{pro } i \in V_1 \\
		-1 & \mbox{pro } i \in V_2
	\end{array}
\right.
\]
Pak pro Laplaceovu matici $Q$ grafu $G$ a diagonální matici $D$ se stupni vrcholů grafu $G$ na diagonále platí:
\begin{align*}
  \vec{x}^T Q \vec{x} &= \vec{x}^T D \vec{x} - \vec{x}^T A_G \vec{x} = \sum_{i=1}^{n}d_i x_i^2 - 2 \sum_{(i,j)\in E} x_i x_j = \\
&=\sum_{(i,j)\in E}(x_i-x_j)^2 =
\sum\limits_{\substack{i \in V_1, j \in V_2 \\ (i,j)\in E}}(x_i-x_j)^2 =
4|\delta(V_1, V_2)|,
\end{align*}
\noindent
čímž jsme převedli problém dělení grafu na problém minimalizace kvadratické formy $\vec{x}^T Q \vec{x}$ přes vektory $\vec{x}$ délky $n$ se složkami $x_i = \pm 1$ takové, že $\sum_{i=1 }^{n}x_i = 0$, tj.
\[
  4 |\delta_{min}(V_1, V_2)| = \min_{\substack{x_i = \pm 1 \\ \sum_{i=1 }^{n}x_i = 0}} \vec{x}^T Q \vec{x}.
  \]
Tento problém dále relaxujeme následovně:
\begin{equation}\label{spektralaprox}
\min_{\substack{x_i = \pm 1 \\ \sum_{i=1 }^{n}x_i = 0}} \vec{x}^T Q \vec{x} \geq \min_{\substack{\sum_{i=1}^{n}x_i^2 = n \\ \sum_{i=1 }^{n}x_i = 0}} \vec{x}^T Q \vec{x}
\end{equation}
Označme $\vec{v_2}$ vlastní vektor matice $Q$ příslušný druhému nejmenšímu vlastnímu číslu matice $Q$. Pak můžeme pomocí Courantovy-Fischerovy věty \cite{hojo:85} výraz na pravé stran nerovnosti \ref{spektralaprox} přepsat jako
\[
\min_{\substack{\sum_{i=1}^{n}x_i^2 = n \\ \sum_{i=1 }^{n}x_i = 0}} \vec{x}^T Q \vec{x} = \vec{v_2}^T Q \vec{v_2} = \lambda_2 \vec{v_2}^T \vec{v_2} = n \lambda_2.
\]
V případě relaxovaného problému nabývá tedy kvadratická forma svého minima pro vektor $v_2$. Nalezneme medián ze složek tohoto vektoru a podle něj provedeme bisekci grafu $G$.

Hlavní myšlenkou spektrálního algoritmu je tedy převést problém dělení grafu na problém hledání vlastních čísel matice, který umíme řešit. Pokud bychom chtěli graf dělit na více než dvě části, potřebovali bychom více vlastních vektorů matice $Q$. Pro dělení na čtyři, resp. osm částí by nám stačily dva, resp. tři vlastní vektory, pro dělení na více částí už nelze postupovat obdobně \cite{lehe:94}. Proto se v takovém případě často přistupuje k rekurzivnímu dělení jednotlivých částí.

\section{Algoritmus podle Kernighana a Lina}
\label{KLalgorithm}
Algoritmus podle Kernighana a Lina (KL algoritmus) vznikl v roce 1970 s cílem dělit elektrické obvody na plošných spojích \cite{keli:70}. V jeho základní podobě se jedná o algoritmus pro vylepšování již získaného rozdělení grafu, pro jeho funkci je tedy nutné poskytnout mu vstupní rozdělení grafu. Pokud používáme KL algoritmus přímo jako dělicí algoritmus, lze vstupní rozdělení zvolit libovolně. Jeho výsledky pro různá počáteční rozdělení se však mohou lišit. Proto je v praxi je výhodné, aby představovalo vstupní rozdělení rozumnou aproximaci optimálního rozdělení. Kvůli tomu se KL algoritmus obvykle používá v kombinaci s jiným algoritmem pro dělení grafů, případně jako součást většího celku - například víceúrovňového dělení grafu ve fázi projekce hrubého rozdělení na vstupní graf (viz kapitola \ref{multilevel}). V tomto případě je vzhledem ke specifickému charakteru úlohy běžně využívána modifikace tohoto algoritmu, která bere v úvahu pouze vrcholy blízko separátoru.

Popišme KL algoritmus pro graf rozdělený na dva podgrafy. Kdyby byl graf obecně rozdělen na $k$ částí, mohli bychom použít tento algoritmus na jednotlivé dvojice podgrafů. Existují i algoritmy založené na KL algoritmu, které přerozdělují graf rozdělený na více než dvě části. Například v \cite{suke:88} najdeme algoritmus pro přerozdělování grafu rozděleného na 4 části.

Mějme graf $G=(V,E)$ rozdělený na dva podgrafy $G_1=(V_1,E_1)$ a $G_2=(V_2,E_2)$. Základním principem KL algoritmu je, že v každé jeho iteraci dojde k výměně určitého počtu vrcholů z množiny $V_1$ za stejný počet vrcholů z množiny $V_2$ tak, aby byla snížena velikost hranového separátoru.

Vrcholy vhodné pro výměnu vybíráme tak, aby při jejich přesunu z části rozdělení, v níž se daný vrchol nachází, do části druhé došlo k maximálnímu zmenšení velikosti hranového separátoru. Tento rozdíl ve velikosti hranového separátoru při přesunu vrcholu $v$ nazveme \textbf{ziskem} $D(v)$ a zřejmě jde o rozdíl počtu hran (případně vah hran) spojujících vrchol $v$ s vrcholy v podgrafu, v němž se vrchol $v$ nachází, a počtu hran spojujících vrchol $v$ s vrcholy v druhém podgrafu. Formálně můžeme zisk pro graf $G=(V,E)$ s rozdělením $P$ a hranovým ohodnocením $c$ zapsat následovně:
\[
D(v) := \sum\limits_{\substack{(u,v) \in E \\ P[u] \neq P[v]}}c(u,v) - \sum\limits_{\substack{(u,v) \in E \\ P[u] = P[v]}}c(u,v).
\]
Pokud přesuneme vrchol s kladným ziskem, dojde ke zmenšení velikosti hranového separátoru.Abychom mohli popsat reálný zisk při výměně vrcholů, je vhodné ještě zavést pro $u,v \in V$ veličinu $C_{uv}$.
\[
C_{uv}=
    \left\{
    \begin{array}{@{\,}ll}
		1  & \mbox{} {u,v} \in E,\\
		0 & \mbox{jinak.}
	\end{array}
\right.
\]
\textbf{Reálný zisk} při výměně vrcholů $u$ a $v$ ležících ve vzájemně různých částech rozdělení grafu $G$ je pak zřejmě
\[
g_{uv}=D(u)+D(v)-2C_{uv}.
\]
Základní varianta KL algoritmu se skládá ze dvou do sebe vnořených cyklů, z nichž vnější běží do té doby, dokud se velikost hranového separátoru zmenšuje a obsahuje tyto kroky:
\begin{enumerate}
  \item Vypočítáme zisk jednotlivých vrcholů.
  \item Postupně spárujeme všechny vrcholy $v_i \in V_1$ s vrcholy $w_j \in V_2$ tak, aby reálný zisk $g_i$ při výměně dvojice vrcholů $(v_k,w_k)$ pro $k \in \left\{1,\ldots,\min(|V_1|,|V_2|)\right\}$ za předpokladu, že by všechny dvojice vrcholů $(v_1,w_1),\ldots,(v_{k-1},w_{k-1})$ byly vyměněné, byl maximální.
  \item Nalezneme takové $N \in \left\{1,\ldots,\min{|V_1|,|V_2|}\right\}$, aby $\sum_{j=1}^{N}g_i$ byla maximální.
  \item Vyměníme vrcholy $v_1,...,v_N$ s vrcholy $w_1,...,w_N$.
\end{enumerate}

Nejjednodušším vylepšením tohoto algoritmu je nechat vnější cyklus běžet po pevně stanovený počet iterací i poté, co již nedochází ke zmenšování velikosti hranového separátoru. Můžeme se díky tomu dostat z lokálního minima \cite{keli:70}. Nejznámějším praktickým vylepšením algoritmu podle Kernighana a Lina je algoritmus publikovaný v \cite{fima:89}, který optimalizuje rychlost výpočtu a aktualizaci zisku pro jednotlivé vrcholy.

\section{Metoda vnořených řezů}

Metoda vnořených řezů byla navržena a publikována v roce 1973 Alanem Georgem \cite{geo:73}. Jedná se o analyticky dobře popsaný algoritmus využívající metodu rozděl a panuj pro řešení problémů na řídkých maticích pomocí jejich převedení na grafy a dělení těchto grafů. V této práci jej uvádíme pro úplnost jakožto příklad algoritmu, který je již ze své podstaty zaveden jako víceúrovňový i přestože se striktně nedrží víceúrovňového schématu. Toto schéma z něj však převzalo myšlenku jak vytvářet hierarchii ale samotná metoda dělení na jednotlivých úrovních a techniky jak hledat oblasti byly nahrazeny. Dalším specifikem metody vnořených řezů je, že se tento algoritmus omezil na dělení grafu na dvě části, zatímco výše popsané víceúrovňové schéma toto omezení nemá.
Metodu vnořených řezů můžeme dále vnímat i jako algoritmus pro hledání vhodného očíslování vrcholů grafu.

Metoda vnořených řezů je teoreticky velmi dobře popsána pro některé speciální typy grafů, například pro čtvercové sítě. Pro obecné grafy bylo navrženo několik heuristických algoritmů, z nichž jeden popíšeme.

\subsection{Jeden řez grafu}

Mějme graf $G = (V,E)$ s maticí sousednosti $A_G$ a nechť $|V| = n$. Nechť $S \subset V$ je vrcholovým separátorem grafu $G$, jehož odebráním dostaneme dva podgrafy grafu $G$ s množinami vrcholů $C_1$, $C_2$. Mějme dále zobrazení $\varphi: V \rightarrow \{1, 2, \ldots, n\}$, které každému vrcholu $v_i \in V$ přiřadí index $i$. Pokud pro zobrazení $\varphi$ platí
\begin{enumerate}
  \item $\varphi^{-1}\left(\{1,\ldots,|C_1|\} \right)=C_1$
  \item $\varphi^{-1}\left(\{|C_1|+1,\ldots,|C_1|+|C_2|\}\right)=C_2$
  \item $\varphi^{-1}\left(\{|C_1|+|C_2|+1,\ldots,n\}\right)=S$,
\end{enumerate}
pak matici sousednosti $A_G$ grafu $G$ lze blokově zapsat ve tvaru
\begin{equation}\label{AG nested}
    A_G =
    \left(
        \begin{matrix}
          A_1   & O     & V_1 \\
          O     & A_2   & V_2 \\
          V_1^T & V_2^T & A_S
        \end{matrix}
    \right),
\end{equation}
kde $A_1$, $A_2$ jsou matice sousednosti podgrafů $G(C_1)$, $G(C_2)$, dále $V_1$, resp. $V_2$ jsou matice charakterizující propojení vrcholů z množiny $C_1$, resp.$C_2$ s vrcholy ze separátoru $S$ a matice $O$ značí nulovou matici. Pro následnou manipulaci s maticí sousednosti $A_G$ je výhodné, aby nulové matice $O$ měly co nejvíce prvků.

Cílem jednoho řezu v metodě vnořených řezů je najít vrcholový separátor $S$ a zobrazení $\varphi$ splňující podmínky výše.

\subsection{Metoda vnořených řezů pro čtvercové sítě}

Popišme metodu vnořených řezů nejprve pro speciální třídu grafů nazývaných čtvercové sítě, se kterými se v praxi můžeme často setkat při diskretizaci složitých systémů.

\textbf{Čtvercovou sítí} o rozměrech $m \times l$, kde $m \leq l$ rozumíme graf o $N = ml$  vrcholech, jehož příklad můžeme vidět zobrazený na obrázku \ref{ctvsit}.

\medskip
{
  \centering
  \includegraphics[scale=0.6]{pictures/ctvercovasit.pdf}
  \captionof{figure}{Čtvercová síť o rozměrech $m=7$ a $l=10$ \label{ctvsit}}
}

\paragraph{Jeden řez čtvercové sítě:}

Mějme čtvercovou síť $N = (V,E)$ o rozměrech $n \times n$ a nechť $S_0 \subset V$. Nechť dále vrcholy z množiny $S_0$ leží v síti na jedné přímce a $S_0$ je vrcholovým separátorem sítě $N$, jehož odebráním dojde k rozpadnutí sítě $N$ na dva podgrafy s množinami vrcholů $V_1$ a $V_2$ s pokud možno stejným počtem prvků. Z konstrukce $S$ jsou tyto podgrafy zřejmě také čtvercovými sítěmi. Očíslujme nyní postupně po řádcích vrcholy z množin $V_1$ a $V_2$ a nakonec očíslujme vrcholy $S_0$. Toto očíslování nazýváme jednoúrovňově-dělicím (one-level dissection ordering) a vidíme, že zřejmě splňuje podmínky kladené výše na zobrazení $\varphi$.

\paragraph{Vnořené řezy pro čtvercovou síť: }

Abychom získali očíslování pro metodu vnořených řezů, pokračujeme v dělení komponent s množinami vrcholů $V_1$, $V_2$. Obdobným způsobem jako v prvním kroku vybereme $S_1$, resp. $S_2$ tak, aby byla vhodným vrcholovým separátorem $G(V_1)$, resp. $G(V_2)$. Nyní opět každou část přečíslujeme tak, aby vrcholy v separátoru měly nejvyšší čísla.
Tím se nám podaří docílit toho, že nejen matice sousednosti, ale i její libovolný diagonální blok má rekurzivně tvar (\ref{AG nested}).

\subsection{Dělení obecných grafů metodou vnořených řezů}
\label{NDobecne}

Pro použití metody vnořených řezů pro obecné grafy existují různé přístupy \cite{litaro:79}. V této kapitole popíšeme jeden z nich. Jedná se o heuristický algoritmus fungující na principu hledání struktury úrovní daného grafu a následného rozdělení grafu podle úrovně "uprostřed".

Mějme souvislý graf $G=(V,E)$. Algoritmus pro jeho rozdělení využívající metodu vnořených řezů pak vypadá následovně.

\begin{enumerate}
  \item Položíme $W=V$ a $N=|V|$.
  \item \label{forloop} Nalezneme souvislou komponentu $G(C)$ grafu $G(W)$.
  \item Vezmeme libovolný vrchol $v\in C$. Vrchol $v$ je vhodné jej volit tak, aby byl daleko od centra grafu \cite{lew:82} $G(C)$. Takový vrchol se nazývá periferní.
  \item Vytvoříme strukturu úrovní $\mathcal{L}=\{L_0, \ldots ,L_l\}$ grafu $G(C)$ vycházející z vrcholu $v$, tj. rozdělíme množinu vrcholů $C$ grafu $G(C)$ na vzájemně disjunktní množiny $L_1, \ldots, L_l$ definované následovně:
      \begin{align*}
        L_0 & := v \\
        L_i & := \mathrm{adj}_{G(C)}(L_{i-1}) \setminus \bigcup_{k=0}^{i-1} L_k \quad {\rm pro} \ i \in \{2,\ldots,l\}
      \end{align*}
  \item Separátor $S$ grafu $G(C)$ volíme následovně. Pokud $l \leq 2$ položíme separátor roven $C$. Jinak definujeme $j := \floor*{\frac{l+1}{2}}$ a separátor položíme roven
      \[
        S = \left\{y \in L_j \mid \mathrm{adj}_{G(C)}(y) \cap L_{j+1} \neq \emptyset \right\}
      \]
  \item Očíslujeme vrcholy separátoru čísly $N-|S|+1,\ldots,N$
  \item Položíme $W:=W \setminus S$ a $N := N-|S|$.
  \item Pokud $W \neq \emptyset$ vrátíme se na krok \ref{forloop}, jinak skončíme.
\end{enumerate}

%----------------------------------------------------------------------

\chapter{Rozklady matic}

Při řešení maticových úloh velkých rozměrů je často výhodné danou matici rozložit na součin dvou nebo více matic a díky tomu původní problém převést na sérii výpočetně jednodušších problémů. Jako klasické příklady úloh z numerické lineární algebry, při jejichž řešení nám mohou rozklady matic pomoci, uveďme hledání řešení soustav lineárních algebraických rovnic či problém nalezení vlastních či singulárních čísel a příslušných vektorů. Rozklady matic navíc hrají nezanedbatelnou roli například v QR algoritmu, LR algoritmu \cite{govl:83} nebo Lanczosově algoritmu \cite{lanc:50,paig:72}. Rozklady matic nám mohou pomoci odhalit i teoretické vlastnosti a strukturu matic a odpovídajících maticových problémů. Příkladem takového rozkladu je singulární rozklad (SVD decomposition) \cite{govl:83}.

Rozklady matic můžeme rozdělit na dvě základní skupiny - úplné rozklady a neúplné rozklady. Úplné rozklady dokážou nalézt z teoretického hlediska přesný výsledek v konečně mnoha krocích (v praxi při výpočtech v konečné počítačové aritmetice tento výsledek přesný být nemusí). Naopak neúplné rozklady jsou iterativními metodami, tj. algoritmy, které získávají v každém svém kroku přesnější aproximaci řešení s použitím výsledku předchozí aproximace a k přesnému výsledku konvergují. Pro získání celkového řešení soustavy je pak třeba je kombinovat s nějakou iterační metodou \cite{temp94}. Vzhledem k našemu cíli zkoumat Choleského rozklad, jakožto zástupce úplných rozkladů, se v dalším textu nebudeme neúplnými rozklady hlouběji zabývat. 

V této práci nás budou zajímat především rozklady, které se týkají řídkých matic, tedy matic, které obsahují velké množství nulových prvků. U takových matic bereme pro zefektivnění výpočtů do úvahy strukturu jejich nenulových prvků. Při výpočtu úplného rozkladu řídké matice může v průběhu rozkladu docházet ke změnám ve struktuře jejích nenulových prvků. Proces výpočtu úplného rozkladu může být pak výpočetně velmi náročný \cite{duiare:86}.

V námi popisovaném základním modelu rozkladů matic se omezíme na úplný rozklad symetrické a pozitivně definitní matice. Nejedná se o samoúčelné omezení, při řešení mnoha praktických úloh se setkáváme právě s maticemi splňujícími tyto podmínky. Navíc se ukazuje, že i pro matice, které nejsou symetrické nebo pozitivně definitní, lze při jejich rozkladech vyjít z tohoto modelu \cite{dara:16}.

\section{Úplné rozklady}

Společným znakem algoritmů pro úplný rozklad matice je, že při práci v přesné aritmetice dokážou tyto algoritmy najít přesný rozklad matice v konečně mnoha krocích. Nejklasičtějším příkladem takovéhoto algoritmu je symetrická eliminace, jejímž speciálním případem je Choleského rozklad, který pro nás bude obzvláště zajímavý. V této kapitole nebudeme ve schématech rozlišovat řídké a husté matice.

\subsection{Symetrická eliminace}

Cílem \textbf{symetrické eliminace} je rozložit danou čtvercovou matici $A$ na tvar $LDL^T$, kde $L$ je dolní trojúhelníková matice a $D$ je diagonální matice. Obecně pro indefinitní matice je třeba pro zajištění numerické stability tohoto algoritmu vynásobit danou matici nějakou permutační maticí \cite{fomo:67}. Pro pozitivně definitní matice je však stabilita zajištěna i bez toho \cite{wil:68}.

Mějme matici $A$ o rozměrech $N \times N$. Symetrickou eliminací matice $A$ nazveme hledání konečných posloupností $(A_j)_{j=0}^{N-1}$, $(L_j)_{j=1}^{N-1}$ splňujících, že $\left(\forall i \in \{1,...,N-1\}\right)\left(A_{i-1}=L_i A_i L_i^T \right)$ a $A_{N-1}=D$.
Předpis pro hledání těchto posloupností je následující:

\begin{gather}
\begin{aligned}
\label{SymEl}
A_0 & = A = \left( \begin{matrix}
               d_1 & v_1^T \\
               v_1 & \bar{H}_1
             \end{matrix} \right)
           =\left(\begin{matrix}
              1               & 0 \\
              \frac{v_1}{d_1} & I_{N-1}
            \end{matrix} \right)
            \left(\begin{matrix}
              d_1 & 0 \\
              0   & \bar{H}_1-\frac{v_1v_1^T}{d_1}
            \end{matrix} \right)
            \left(\begin{matrix}
              1 & \frac{v_1^T}{d_1} \\
              0 & I_{N-1}
            \end{matrix} \right) \\
    &     = L_1
            \left(\begin{matrix}
              d_1 & 0 \\
              0 & H_1
            \end{matrix} \right)
            L_1^T
          = L_1 A_1 L_1^T \\
  A_1 & = \left( \begin{matrix}
               d_1 &  0   & 0 \\
               0   &  d_2 & v_2^T \\
               0   &  v_2 & \bar{H}_2
             \end{matrix} \right)
        =  L_2 A_2 L_2^T \\
    & \vdots \\
  A_{N-1} & = D,
\end{aligned}
\end{gather}

kde $H_i=\bar{H}_i-\frac{v_i v_i^T}{d_i}$.
Zřejmě pak $A = LDL^T$, kde $L:=L_1\cdots L_{N-1}$.

\subsection{Choleského rozklad}
\label{CholeskyChapter}
\textbf{Choleského rozklad} je speciálním případem symetrické eliminace. Jeho cílem je rozložit pozitivně definitní matici $A$ na tvar $A=LL^T$, kde matici $L$ označujeme jako Choleského faktor matice $A$. Jinými slovy se jedná o symetrickou eliminaci matice $A$, kde požadujeme, aby matice $D$ byla rovna jednotkové matici. Z praktického hlediska jde o modifikaci Gaussovy eliminační metody pro symetrické pozitivně definitní matice. Základní informaci o existenci Choleského rozkladu pozitivně definitní matice nám dává následující věta, jejíž důkaz můžeme nalézt například v \cite{govl:83}.

\begin{theorem}
  Pro libovolnou pozitivně definitní matici $A$ existuje jednoznačný rozklad $A=LL^T$, kde L je dolní trojúhelníková matice s kladnými prvky na diagonále.
\end{theorem}

Pro výpočet Choleského rozkladu matice $A$ stačí modifikovat algoritmus \ref{SymEl} tak, aby matice $D$ vznikající při symetrické eliminaci matice $A$ byla rovná jednotkové matici. Toho dosáhneme následovně:

\begin{gather}
\begin{aligned}
\label{Cholesky}
A_0 & = A = \left( \begin{matrix}
               d_1 & v_1^T \\
               v_1 & \bar{H}_1
             \end{matrix} \right)
           =\left(\begin{matrix}
              \sqrt{d_1}      & 0 \\
              \frac{v_1}{\sqrt{d_1}} & I_{N-1}
            \end{matrix} \right)
            \left(\begin{matrix}
              1   & 0 \\
              0   & \bar{H}_1-\frac{v_1v_1^T}{d_1}
            \end{matrix} \right)
            \left(\begin{matrix}
              \sqrt{d_1} & \frac{v_1^T}{\sqrt{d_1}} \\
              0 & I_{N-1}
            \end{matrix} \right) \\
    &     = L_1
            \left(\begin{matrix}
              1 & 0 \\
              0 & H_1
            \end{matrix} \right)
            L_1^T
          = L_1 A_1 L_1^T \\
  A_1 & = \left( \begin{matrix}
               1   &  0   & 0 \\
               0   &  d_2 & v_2^T \\
               0   &  v_2 & \bar{H}_2
             \end{matrix} \right)
        =  L_2 A_2 L_2^T \\
    & \vdots \\
  A_{N-1} & = L_N I_N L_N^T,
\end{aligned}
\end{gather}

kde opět zřejmě platí, že $L=L_1...L_N$.

\medskip

Matici $L$ můžeme však z matic $L_1,\ldots,L_N$ vypočítat výrazně jednodušším způsobem.

\begin{lemma}
\label{Lsoucet}
    Při konstrukci Choleského rozkladu $LL^T$ matice $A$ pomocí algoritmu (\ref{Cholesky}) platí
    \begin{equation}
      L = L_1 + L_2 + \ldots + L_N - (N-1)I_N,
    \end{equation}
    tj. $i$-tý sloupec $L$ je roven $i$-tému sloupci $L_i$.
\end{lemma}
\begin{proof}
  Matice $L_i$ má tvar
  \[
  \left(
  \begin{matrix}
    1 &        &   &                              &   &        &   \\
      & \ddots &   &                              &   & 0      &   \\
      &        & 1 &                              &   &        &   \\
      &        &   & \sqrt{d_i}                   &   &        &   \\
      &        &   & \frac{\vec{v_i}}{\sqrt{d_i}} & 1 &        &   \\
      & 0      &   &                              &   & \ddots &   \\
      &        &   &                              &   &        & 1
  \end{matrix}
  \right).
  \]
  Vynásobením matic $L_i$ a $L_j$, kde $i < j$, zjevně dostanu
  \[
  \left(
  \begin{matrix}
    1 &        &   &                              &   &        &   \\
      & \ddots &   &                              &   & 0      &   \\
      &        & \sqrt{d_i} &     &   &        &   \\
      &        & \frac{\vec{v_i}}{\sqrt{d_i}}  &     \ddots               &   &        &   \\
      &        &   &  & \sqrt{d_j} &        &   \\
      & 0      &   &  & \frac{\vec{v_j}}{\sqrt{d_j}}  & \ddots &   \\
      &        &   &  &   &        & 1
  \end{matrix}
  \right),
  \]
  což je přesně matice $L_i + L_j - I$.
  Z toho již plyne tvrzení lemmatu.
\end{proof}

Pro výpočet prvků matice $L$ existují tři základní postupy: submaticové schéma vyplývající přímo z Lemmatu \ref{Lsoucet}, řádkové schéma s použitím metody ohraničování a sloupcové schéma. V přesné aritmetice jsou všechna tři tato schémata ekvivalentní, ale v případě aritmetiky v konečné přesnosti, se kterou se standardně při počítačových výpočtech setkáváme, můžou schémata dávat různé výsledky. Tato schémata napočítávají prvky matice $L$ v různém pořadí.

\paragraph{Submaticové schéma}
S pomocí Lemmatu \ref{Lsoucet} můžeme navrhnout submaticové schéma pro výpočet faktoru $L$ následovně. Matici $L$ získáváme po sloupcích, ale při výpočtu $i$-tého sloupce zároveň počítáme submatici $H_i = \bar{H}_i-\frac{v_i v_i^T}{d_i}$ matice $A$, kterou potřebujeme pro výpočet zbylých částí faktoru matice $A$ (viz algoritmus (\ref{Cholesky})).

\paragraph{Řádkové schéma - metoda ovroubení}
Jiným přístupem, který můžeme zvolit pro získání Choleského rozkladu $L L^T$ matice $A$ je řádkové schéma využívající metodu ovroubení (bordering method) \cite{fad:59, ort:88}. Nejprve přepišme matici $A$ do tvaru
\[
A =
\begin{pmatrix}
  M & \vec{u} \\
  \vec{u^T} & s
\end{pmatrix},
\]
přičemž pro odvození vztahu pro výpočet prvků faktoru $L$ předpokládejme, že Choleského rozklad $L_M L_M^T$ matice $M$ již známe. Pak pro Choleského rozklad matice $A$ platí:
\[
A =
\begin{pmatrix}
  L_M & 0 \\
  \vec{w}^T & t
\end{pmatrix}
\begin{pmatrix}
  L_M^T & \vec{w} \\
  0 & t
\end{pmatrix},
\]
kde je zřejmě $\vec{w}=L_M^{-1}\vec{u}$ a $t=(s-\vec{w}^T\vec{w})^{1/2}$.

Pro získání Choleského rozkladu matice $M$, jehož znalost jsme výše předpokládali, můžeme použít stejný postup. Rekurzivním použitím této metody dostáváme soustavu lineárních algebraických rovnic pro výpočet $i$-tého řádku matice $L$, kde $l_{i,j}$ značí $(i,j)$-tý prvek matice $L$.
\begin{gather*}
\begin{pmatrix}
  l_{1,1} &  & 0 \\
  \vdots  & \ddots &  \\
  l_{i-1,1} & \cdots & l_{i-1,i-1}
\end{pmatrix}
\begin{pmatrix}
  l_{i,1} \\
  \vdots \\
  l_{i,i-1}
\end{pmatrix}
=
\begin{pmatrix}
  a_{i,1} \\
  \vdots \\
  a_{i,i-1}
\end{pmatrix} \\
 l_{i,i} = \left(a_{i,i} - \sum_{j=1}^{i-1}{l_{i,j}^2}\right)^\frac12.
\end{gather*}

\paragraph{Sloupcové schéma}
Jedná se o obdobný postup jako v řádkovém schématu, pouze napočítáváme prvky matice $L$ po sloupcích. Vzorce, které nám pro výpočet prvků matice $L$ vzniknou jsou pro $j = 1,2,\ldots, N$ a pro $i = j+1,j+2,\ldots,N$ následující:
\begin{align*}
  l_{j,j} &= \left(a_{j,j} - \sum_{k=1}^{j-1}{l_{j,k}^2}\right)^\frac12 \\
  l_{i,j} &= \left(a_{i,j} - \sum_{k=1}^{j-1}{l_{i,k}l_{j,k}}\right)/l_{j,j}.
\end{align*}

\subsubsection{Choleského rozklad řídkých matic}
\label{Choleskysparse}

V praktických aplikacích Choleského rozkladu se často setkáváme s řídkými maticemi, navíc jsou pro nás řídké matice zajímavé i z hlediska dělení příslušných grafů. Pokud máme řídkou matici, v optimálním případě bychom chtěli, aby i její Choleského faktor byl řídká matice, jejíž dolní trojúhelníková část má stejnou strukturu jako dolní trojúhelníková část původní matice.

Mějme čtvercovou matici $A$ o rozměrech $N\times N$ a její Choleského rozklad $LL^T$. Základním problémem výše zmíněných algoritmů je, že matice $L$ běžně obsahuje nenulové prvky na místech, na nichž měla matice $A$ nuly. Toto zaplňování je způsobeno při vytváření posloupnosti matic $H_i$ (viz Algoritmus \ref{Cholesky}), konkrétně při přechodu od matice $\bar{H}_i$ k matici $H_i$. Připomeňme, že mezi těmito dvěma maticemi platí vztah
\[
H_i = \bar{H}_i - \frac{\vec{v_i}\vec{v_i}^T}{d_i}.
\]
Označme $\eta(A)$, resp. $\eta(\vec{v})$ počet nenulových prvků matice $A$, resp. vektoru $v$. Pak z Lemmatu \ref{Lsoucet} a ze vztahu pro výpočet $L_i$ v Choleského algoritmu \ref{Cholesky} zřejmě platí
\[
\eta(L) = N + \sum_{i=1}^{N-1}\eta(\vec{v_i}).
\]
Vyslovme větu, ze které nám vyplyne počet informaci o počtu multiplikativních operací (násobení a dělení) potřebných pro pro výpočet Choleského rozkladu matice $A$.
\begin{theorem}
\label{Cholesky_operace}
  Počet multiplikativních operací potřebných pro výpočet Choleského rozkladu $LL^T$ matice $A$ o rozměrech $N \times N$ je roven
  \[
  \frac12\sum_{i=1}^{N-1}\eta(v_i)\left(\eta(v_i)+3\right)=
  \frac12\sum_{i=1}^{N-1}\left(\eta(L_{*i})-1\right)\left(\eta(L_{*i})+2\right),
  \]
  kde $L_{*i}$ označuje $i$-tý sloupec matice $L$.
\end{theorem}
\begin{proof}
  Jednotlivá schémata pro výpočet matice $L$ popsaná v předchozí kapitole se liší pouze v pořadí, v němž výpočet prvků matice $L$ provádějí.

  V $i$-tém kroku algoritmu potřebujeme $\eta(\vec{v_i})$ operací pro výpočet $v_i/\sqrt{d_i}$ a $\frac12\eta(\vec{v_i})\left(\eta(\vec{v_i})+1\right)$ operací pro vytvoření matice $\frac{\vec{v_i}\vec{v_i}^T}{d_i}$. Tvrzení věty dostaneme sečtením přes všechna $i$.
\end{proof}

\begin{remark}
Pro hustou matici $B$ platí, že počet nenulových prvků v jejím Choleského faktoru $L_B$ je roven $\frac12 N(N+1)$.
Z Věty \ref{Cholesky_operace} je tedy počet operací potřebný pro výpočet Choleského rozkladu matice $B$ roven
\begin{equation}\label{pocetoperaci}
  \frac12 \sum_{1}^{N-1}i(i+3) = \frac16 N^3 + \frac12 N^2 - \frac23 N.
\end{equation}
Z toho plyne, že počet operací pro výpočet Choleského rozkladu libovolné řídké matice o rozměrech $N \times N $ lze seshora odhadnout číslem daným vztahem (\ref{pocetoperaci}).
\end{remark}

Problém zaplňování se dá alespoň částečně vyřešit tím, že místo rozkladu matice $A$ provádíme rozklad matice $PAP^T$, kde $P$ je nějaká permutační matice (tj. matice, kterou když vynásobíme matici $A$, dojde pouze k permutaci řádků, resp. sloupců matice $A$). Vzhledem k tomu, že jsme od začátku předpokládali, že je matice $A$ symetrická a pozitivně definitní, je i matice $PAP^T$ symetrická a pozitivně definitní. Pokud máme zadán problém řešení soustavy $Ax=b$, převedeme jej na problém řešení soustavy $(PAP^T)(Px)=Pb$. Tento problém je úzce spjat s problémem očíslování grafů při jejich dělení a budeme se jím zabývat v dalších kapitolách.

%----------------------------------------------------------------------

\chapter{Další parametry pro dělení grafu}
\label{dalsiParametry}

Dělení grafu lze využít jako nástroj pro paralelizaci problémů, které lze převést na úlohy na grafech. Jedním z takových problémů je problém minimalizace zaplnění v Choleského faktoru dané matice pomocí permutace řádků a sloupců popsaný v kapitole \ref{Choleskysparse}, který lze vzhledem ke vztahu matic a grafů popsanému výše v kapitole \ref{GrMatRel} převést na problém dělení odpovídajícího grafu.

Jak bylo zmíněno, při dělení grafu podle klasické definice bereme ohled pouze na dvě kritéria: na velikost separátoru a vyváženost jednotlivých částí rozdělení. V případě, že dělení grafu využíváme jako součást komplexnějšího algoritmu, například pro paralelizaci nějaké maticové úlohy, nemusí být rozdělení vytvořené s ohledem na tato kritéria optimální. V takovém případě je nutné brát ohled na to, jaké operace budeme na výsledných podgrafech provádět a v závislosti na tom specifikovat nová kritéria. Pro dělení grafu s ohledem na více než dvě základní kritéria popsaná výše existují dva základní přístupy. Můžeme hledat rozdělení grafu optimalizující všechna kritéria zároveň (apriorní přístup), nebo můžeme graf rozdělit pomocí některého ze základních algoritmů pro dělení grafu a poté vzniklé rozdělení vylepšit tak, abychom optimalizovali vyváženost operací (aposteriorní přístup).

V této práci se zaměříme na situaci, kdy je dělení grafů použito jako nástroj pro vyvažování počtu operací na jednotlivých oblastech při paralelizaci Choleského rozkladu. Požadujeme tedy, aby počet operací potřebný pro Choleského rozklad na jednotlivých oblastech byl v optimálním případě stejný a zároveň co nejmenší. Zřejmě nám takto vzniká kritérium, které není zahrnuto v kritériích podle klasické definice - ta totiž neberou v potaz hustotu hran v podgrafech vzniklých dělením původního grafu, neboli v řeči matic počet nenulových prvků matic sousednosti jednotlivých podgrafů. Počet operací potřebných pro vypočítání rozkladu na jednotlivých oblastech může být kvůli tomu výrazně odlišný. Námi navržený algoritmus bude využívat aposteriorního přístupu, nejprve tedy nalezneme suboptimální řešení vzhledem k základním kritériím a poté budeme hledat vhodné očíslování vrcholů daných podgrafů a přesouvat vrcholy mezi jednotlivými částmi rozdělení s cílem vylepšit jej vzhledem k Choleského rozkladu.

Mějme graf $G$ a jeho rozdělení na podgrafy $G_1, \ldots, G_k$ s maticemi sousednosti $A_{G_1}, \ldots, A_{G_k}$. Provedeme Choleského rozklad matic $A_{G_1}, \ldots, A_{G_k}$, označme
\[
  A_{G_i} = L_{G_i}L_{G_i}^T \ {\rm pro} \ i \in \{1,\ldots,k\}.
\]
Pokud existují $i,j \in \{1,\ldots,k \}$ takové, že matice $L_{G_i}^T$ a $L_{G_j}^T$ mají výrazně různý počet nenulových prvků, je zřejmé, že toto rozdělení grafu $G$ je nevhodné pro napočítávání Choleského rozkladu na oblastech vzhledem k vyváženosti na počet operací. Někdy pro vyvážení rozdělení za účelem Choleského rozkladu na oblastech stačí vhodně přečíslovat vrcholy podgrafů $G_1, \ldots, G_k$ a tím změnit matice sousednosti odpovídající jednotlivým podgrafům.

\begin{remark}
Mějme soustavu lineárních algebraických rovnic $Ax=b$ a hledejme její řešení pomocí Choleského rozkladu této matice $A=LL^T$ za pomoci dělení grafů. Pro vyřešení soustavy potřebujeme vyřešit rovnice
\begin{align*}
  Ly =& b \\
  L^Tx= & y
\end{align*}
Pokud rozdělíme graf příslušný matici $A$ na $k$ částí a provedeme rozklad matic $A_1=L_1 L_1^T, \ldots, A_k=L_k L_k^T$ odpovídajících vzniklým podgrafům a matice $A_S=L_S L_S^T$ odpovídající vrcholovému separátoru, pak lze soustavu $Ly=b$ napsat ve tvaru
\[
\begin{pmatrix}
  L_1 &     &        &      & \\
      & L_2 &        &      & \\
      &     & \ddots &      & \\
      &     &        & L_k  & \\
  S_1 & S_2 &        & S_k  & L_S
\end{pmatrix}
\begin{pmatrix}
  y_1 \\
  y_2 \\
  \vdots \\
  y_k \\
  y_S
\end{pmatrix}
=
\begin{pmatrix}
  b_1 \\
  b_2 \\
  \vdots \\
  b_k \\
  b_S
\end{pmatrix},
\]
a tedy
\begin{align*}
  y_1= & L_1^{-1}b_1 \\
  y_2= & L_2^{-1}b_2 \\
  \vdots \\
  y_k= & L_k^{-1}b_k \\
  y_S= & L_S^{-1}(b_S - S_1 y_1 - S_2 y_2 - \ldots - S_k y_k).
\end{align*}
Je vidět, že zatímco výpočet $y_1, \ldots, y_k$ může probíhat paralelně, výpočet $y_S$ je závislý na $y_1, \ldots, y_k$. Je tedy vhodné, aby vrcholový separátor byl malý.


Soustavu $L^Tx=y$ poté vyřešíme obdobně.
\end{remark}

\medskip

Jak vidíme, při dělení grafu s cílem vypočítávat Choleského rozklad na oblastech nám vyvstávají dvě základní otázky:
\begin{enumerate}
  \item Jak najít očíslování podgrafů vzniklých dělením původního grafu takové, aby k vypočítání Choleského rozkladu na jednotlivých oblastech bylo potřeba co nejméně operací?
  \item Jak určit počet nenulových prvků v Choleského faktoru matice bez toho, abychom Choleského rozklad vypočítali?
\end{enumerate}
Způsob hledání odpovědí na tyto dvě otázky popíšeme v následujících dvou podkapitolách.

\section{Algoritmy pro očíslování vrcholů grafu}
\label{Numbering}
V této podkapitole popíšeme základní algoritmy pro očíslování vrcholů grafu. Zřejmě platí, že přečíslování vrcholů grafu odpovídá permutaci řádků a sloupů v jeho matici sousednosti. Hlavní motivací, proč je pro nás číslování vrcholů grafu důležité, tedy je, že permutací řádků matice můžeme výrazně redukovat počet operací potřebných pro její Choleského rozklad, jak jsme zmínili výše.

Na závěr kapitoly se zmíníme o topologickém číslování vrcholů stromu, které pro nás bude potřebné při popisu eliminačních stromů v kapitole \ref{eltreeChapter}.

\subsection{Číslování vrcholů grafu v závislosti na vzdálenosti od separátoru}
\label{sepDistOrdering}

V tomto oddíle popíšeme nejjednodušší metodu číslování vrcholů podgrafu, který vznikl rozdělením původního grafu na $n$ částí.
Tuto metodu lze používat samostatně, ale vzhledem k její povaze ji lze využít i pro vylepšení ostatních metod očíslování grafu,
například ji lze kombinovat s metodou minimálního stupně.

Mějme graf $G = (V,E)$ a jeho vrcholový separátor $G_S$, jehož odebráním se graf rozpadne na $k$ podgrafů $G_1, \ldots, G_k$.
Popišme číslování vrcholů podgrafu $G_i$:

\begin{enumerate}
  \item Položme $\texttt{j := 1}$.
  \item \label{sepDistAlg2} Nalezneme neočíslovaný vrchol $v$ grafu $G_i$ takový, že jeho vzdálenost od vrcholového separátoru v grafu $G$ je maximální.
  \item Tomuto vrcholu dáme číslo $\texttt{j}$, položíme $\texttt{j := j + 1}$.
  \item Pokud jsou všechny vrcholy očíslovány, skončíme, jinak se vrátíme na krok \ref{sepDistAlg2}
\end{enumerate}

Z algoritmu je vidět, že výsledné očíslování vrcholů grafu nemusí být jednoznačné, protože pokud nalezneme dva nebo více vrcholů, jejichž vzdálenost od separátoru je shodná, můžeme je očíslovat v libovolném pořadí.

\subsection{Číslování vrcholů pomocí metody minimálního stupně}
\label{MDordering}
Metoda minimálního stupně je jednoduchým algoritmem pro nalezení očíslování grafu. Algoritmus pro hledání očíslování grafu pomocí této metody je následující:

\begin{enumerate}
  \item Mějme graf $G=(V,E)$ a položme $\texttt{j := 1}$.
  \item \label{mindegloop}
      Nalezneme neočíslovaný vrchol $v$ grafu $G$ s nejmenším stupněm a přiřadíme mu číslo $\texttt{j}$.
  \item Přidáme hrany mezi vrcholy z $\mathrm{adj}_G(v)$ tak, aby $G(\mathrm{adj}_G(v))$ byla klika v grafu $G$.
  \item Pokud nejsou všechny vrcholy očíslované, položíme $\texttt{j := j + 1}$ a vrátíme se na krok \ref{mindegloop}.
\end{enumerate}

Očíslování vrcholů grafu G pomocí tohoto algoritmu není jednoznačné, protože vrcholů s minimálním stupněm může být více.

\subsection{Smíšené číslování}
\label{Mixedordering}
Vzhledem k povaze číslování popsaných v oddílech \ref{MDordering} a \ref{sepDistOrdering} můžeme tyto algoritmy zkombinovat. V tomto oddíle popisujeme dvě možnosti přístupu k tomuto problému.

Pokud máme rozdělení $G_1, \ldots, G_k$ grafu $G$ s vrcholovým separátorem $G_S$, můžeme pro očíslování části $G_i$ použít číslování vrcholů pomocí metody minimálního stupně, kde při výběru vrcholu ve \ref{mindegloop}. kroku algoritmu popsaného v \ref{MDordering} přidáme kritérium vzdálenosti od separátoru popsané v \ref{sepDistOrdering}. Nejprve tedy nalezneme množinu všech vrcholů grafu $G$, které mají minimální stupeň a poté z nich zvolíme ten, který je nejdál od vrcholového separátoru.

Druhou možností, jak je výše zmíněná očíslování možné kombinovat je použít jejich konvexní kombinaci. Tímto způsobem nemusíme kombinovat pouze očíslování popsaná v oddílech \ref{MDordering} a \ref{sepDistOrdering}, ale můžeme jej použít na libovolná očíslování. Mějme množinu vrcholů $V$, $|V|=n$ a dvě různá očíslování $\varphi,\psi :V \rightarrow \{1,\ldots,n\}$. Nechť dále $\alpha \in [0,1]$. Napočítáme pro každý vrchol $v$ hodnotu výrazu $\alpha\varphi(v) + (1-\alpha)\psi(v)$. Smíšené očíslování vytvoříme tak, že vrcholy seřadíme podle této hodnoty od nejmenší po největší. Ač by se mohlo zdát, že tento postup nám nemůže přinést nic nového, nemusí to být pravidlem\cite{slo:89,resc:99}.

\subsection{Topologické číslování vrcholů stromu}
Topologické číslování vrcholů stromu je intuitivní způsob pro očíslování vrcholů grafu, který je stromem.
\begin{definition}
    Mějme graf $G = (V,E)$, který je stromem. Očíslování jeho vrcholů nazveme topologickým právě tehdy,
    když pro každý vrchol $v \in V$ platí, že libovolný následník vrcholu $v$ ve stromu $G$ má nižší číslo než vrchol $v$.
\end{definition}


\section{Eliminační stromy}
\label{eltreeChapter}

V této kapitole se budeme zabývat eliminačními stromy a jejich významem pro rozklady řídkých matic \cite{liu:86,liu:90}. Eliminační stromy při rozkladu matic hrají důležitou roli, protože nám dávají informaci o zaplnění v Choleského faktoru matice bez toho, abychom museli počítat jednotlivé numerické hodnoty. Lze tedy díky nim jednoduše porovnávat vhodnost zvoleného uspořádání řádků a sloupců matice pro Choleského rozklad.

V této kapitole bez újmy na obecnosti předpokládáme, že matice, jejíž Choleského rozklad chceme napočítávat, je ireducibilní, a tedy graf odpovídající této matici je souvislý.

\subsection{Definice eliminačního stromu matice}

Nejprve se omezme na ireducibilní, pozitivně definitní, symetrickou matici $A_T$ o rozměrech $n \times n$, jejíž přidružený graf $G(A_T)$ je kořenový strom. Aby při Choleského rozkladu matice $A_T$ nedošlo k žádnému zaplnění, stačí když pomocí topologického číslování očíslujeme vrcholy jí přidruženého grafu (z předpokladu se jedná o strom) a řádky a sloupce matice $A_T$ seřadíme odpovídajícím způsobem. Pak zjevně platí, že matice $A_T$ má, s výjimkou posledního sloupce, pod diagonálou vždy právě jeden nenulový prvek. Díky této vlastnosti označujeme $A_T$ jako perfektní eliminační matici, tj. existuje permutační matice $P$ taková, že Choleského rozklad matice $PA_TP^T$ nebude obsahovat žádné zaplnění \cite{rose:72} (Matici $PA_TP^T$ můžeme vnímat pouze jako přečíslování řádků a sloupců matice $A_T$). 

Proto pro matici $A_T$ můžeme definovat funkci $\texttt{PARENT}:\{1,\ldots,n\} \rightarrow \{1,\ldots,n\}$ následovně:
\begin{align*}
  \forall j \in \{1,\ldots,n-1\} \quad \texttt{PARENT}[j] & := p \quad \Leftrightarrow \quad a_{p,j} \neq 0 \ \wedge \ p > j \\
  \text{a speciálně:} \quad \texttt{PARENT}[n] & := 0.
\end{align*}
Zřejmě ve stromu přidruženém k matici $A_T$ platí, že předchůdcem vrcholu $x_j$ je vrchol $x_{\texttt{PARENT}[j]}$.

Většinou však nepracujeme s maticemi, jejichž přidružený graf by byl stromem. Zobecněme tedy výše popsanou konstrukci pro libovolnou řídkou, ireducibilní, pozitivně definitní, symetrickou matici $A$ o rozměrech $n \times n$. Předpokládejme, že známe Choleského rozklad této matice, tj. $A = LL^T$. \textbf{Maticí se zaplněním} nazveme matici $F$ definovanou jako $F = L + L^T$. Dále zavedeme matice $L_t$ a $F_t$ následovně: $L_t$ je matice vzniklá z $L$ tím, že v každém sloupci vynulujeme všechny prvky pod diagonálou kromě prvku s nejnižším řádkovým indexem a $F_t := L_t + L_t^T$.

Z definice $F_t$ vidíme, že se jedná o matici, jejíž přidružený graf $G(F_t)$ je strom. Díky tomu můžeme vyslovit následující definici.

\begin{definition}
    \textbf{Eliminačním stromem} matice $A$ nazveme graf $G(F_t)$ popsaný výše a značíme jej $T(A)$.
    Podstrom eliminačního stromu $T(A)$ s kořenem $x_j$ značíme $T[x_j]$. Nemůže-li dojít k záměně, značíme množinu vrcholů tohoto stromu taktéž $T[x_j]$.
\end{definition}

Díky této definici můžeme funkci $\texttt{PARENT}$ přirozeně rozšířit na matici $A$ následovně:
\[
    \texttt{PARENT}[j] := \min \left\{ i > j \ | \ [L]_{i,j} \neq 0\right\},
\]

\begin{observation}
Přímo z definice plyne, že $T(A)$ a $T(F)$ jsou identické.
\end{observation}

\begin{observation}
Pokud $x_i$ je vlastním předchůdcem $x_j$ v eliminačním stromu, pak $i > j$.
\end{observation}

\begin{proposition}
  \label{ColDepProposition}
  Nechť $A$ je řídká, ireducibilní, pozitivně definitní, symetrická matice o rozměrech $n \times n$ s Choleského rozkladem $LL^T$ a nechť $i,j \in \left\{1,\ldots,n \right\}$, $i > j$. Pak numerické hodnoty sloupce $L_{\bullet i}$ závisí na sloupci $L_{\bullet j}$ právě tehdy,
  když $[L]_{i,j} \neq 0$.
\end{proposition}
\begin{proof}
  Tvrzení plyne přímo ze vzorců pro výpočet Choleského rozkladu pomocí sloupcového algoritmu popsaného v kapitole \ref{CholeskyChapter}
\end{proof}

Přímým důsledkem tvrzení \ref{ColDepProposition} je, že graf $G(F)$ zachycuje informace o závislostech mezi jednotlivými sloupci při výpočtu Choleského rozkladu. 

\subsection{Využití a konstrukce eliminačních stromů}
\label{EltreeAlgSection}

Z definice eliminačních stromů je zřejmé, že budou obsahovat velké množství informací o rozkladu matice a procesu jeho vytváření. Například v \cite{schr:82} byly popsány vlastnosti eliminačních stromů vzhledem ke Gaussově eliminaci. My však budeme eliminační stromy využívat jako nástroj pro výpočet počtu nenulových prvků v Choleského faktoru matice \cite{liu:90}. Uveďme větu, která dává do souvislosti nenulové prvky v Choleského faktoru a strukturu eliminačního stromu \cite{liu:86}.

\begin{theorem}
  Nechť $A$ je řídká, ireducibilní, pozitivně definitní, symetrická matice o rozměrech $n \times n$ s Choleského rozkladem $LL^T$ a nechť $i,j \in \left\{1,\ldots,n \right\}$. Pak $[L]_{i,j} \neq 0$ právě tehdy, když vrchol $v_j$ je v eliminačním stromě následníkem vrcholu $v_k$ takového, že $[A]_{i,j} \neq 0$.
\end{theorem}

Tato věta nám dává návod, jak vypočítat počet nenulových prvků v Choleského faktoru. Uveďme algoritmus popsaný v \cite{liu:90}, který nám dává návod, jak napočítat počty nenulových prvků v jednotlivých řádcích a sloupcích Choleského faktoru. Obdobný algoritmus s důrazem na implementaci na multiprocesorech můžeme nalézt v \cite{zmgi:88}. Námi popsaný algoritmus je poměrně jednoduchý. Efektivnější, ale složitější algoritmus pro výpočet počtu nenulových prvků můžeme najít v \cite{gil:94}. Dále v \cite{basm:87} můžeme najít postup, jakým napočítávat počet nenulových prvků ve faktoru a strukturu eliminačního stromu současně.

V uvedeném Algoritmu \ref{nonzerosAlgorithm} je použit pracovní vektor \Marker, který složí k označování vrcholů eliminačního stromu, které byly v dané iteraci již uvažovány - indexování vrcholů eliminačního stromu uvažujeme tak, aby odpovídalo vstupní matici. Eliminační strom je popsán pomocí vektoru $\texttt{PARENT}$, který byl zmíněn výše.

\begin{figure}[ht]
  \centering
  \begin{minipage}{.5\linewidth}
    \begin{algorithm}[H]
      \SetAlgoNoLine
      
      \SetKwArray{Parent}{$\texttt{PARENT}$}

      \For{$j:=1$ \KwTo $n$}{
        $\eta(L_{*j}) := 1$\;
      }
      \For{$i:=1$ \KwTo $n$}{
        $\eta(L_{i*}) := 1$\;
        \Marker{$i$} $ := i$\;
        \For{$k:=1$ \KwTo $i-1$}{
          \If{$[A]_{i,k} \neq 0$}{
            $j:= k$\;
            \While{\Marker{$j$} $\neq i$}{
              $\eta(L_{i*}) := \eta(L_{i*}) + 1$\;
              $\eta(L_{*j}) := \eta(L_{*j}) + 1$\;
              \Marker{$j$} $=i$\;
              $j := $\Parent{$j$}\;
            }
          }
        }
      }
    \end{algorithm}
  \end{minipage}
  \captionof{algocf}{Výpočet počtu nenulových prvků z eliminačního stromu (\cite{liu:90}, upraveno) \label{nonzerosAlgorithm}}
\end{figure}

Algoritmus \ref{nonzerosAlgorithm} nám dává návod jak vypočítat počet prvků v jednotlivých řádcích a sloupcích matice. Pokud nás zajímá pouze počet nenulových prvků v celé matici, můžeme počítat pouze počet prvků v řádcích, resp. sloupcích.

Díky Algoritmu \ref{nonzerosAlgorithm} dostáváme odpověď na otázku, jak zjistit počet nenulových prvků v matici $L$ z eliminačního stromu matice $A$. Pokud bychom eliminační strom vytvářeli přímo z definice, museli bychom vypočítat Choleského rozklad. Proto potřebujeme algoritmus, který nám sestrojí Eliminační strom - tedy vektor $\texttt{PARENT}$ - bez toho.

Uveďme základní algoritmus pro sestrojení eliminačního stromu matice bez výpočtu jejího Choleského rozkladu (Algoritmus \ref{eltree1Algorithm}). Dále popišme jeho vylepšení (Algoritmus \ref{eltree2Algorithm}), v němž pro zrychlení Algoritmu \ref{eltree1Algorithm} používáme pomocný vektor $\texttt{ANCSTR}$, který nám zkrátí procházení stromu směrem od listů ke kořeni. V tomto pomocném vektoru je pro každý vrchol zaznamenáván jeho poslední zpracovaný předek. Oba algoritmy jsou převzaté z \cite{liu:86}. 

\begin{figure}[ht]
  \centering
  \begin{minipage}{.7\linewidth}
    \begin{algorithm}[H]
      \SetAlgoNoLine
      
      \SetKwArray{Parent}{$\texttt{PARENT}$}

      \For{$i:=1$ \KwTo $n$}{
        \Parent{$i$} $= 0$\;
        \For{$j:=1$ \KwTo $i-1$}{
          \If{$[A]_{i,j} \neq 0$}{
            $r:= j$\;
            \While{\Parent{$r$} $\neq 0$ {\bf and} \Parent{$r$} $\neq i$}{
              $r := $\Parent{$r$}\;
            }
            \If{\Parent{$r$} $== 0$}{
              \Parent{$r$} $:= i$\;
            }
          }
        }
      }
    \end{algorithm}
  \end{minipage}
  \captionof{algocf}{Základní algoritmus pro hledání eliminačního stromu (\cite{liu:86}, upraveno) \label{eltree1Algorithm}}
\end{figure}

\begin{figure}[ht]
  \centering
  \begin{minipage}{.7\linewidth}
    \begin{algorithm}[H]
      \SetAlgoNoLine
      
      \SetKwArray{Parent}{$\texttt{PARENT}$}
      \SetKwArray{Ancestor}{$\texttt{ANCSTR}$}

      \For{$i:=1$ \KwTo $n$}{
        \Parent{$i$} $= 0$\;
        \Ancestor{$i$} $= 0$\;
        \For{$j:=1$ \KwTo $i-1$}{
          \If{$[A]_{i,j} \neq 0$}{
            $r:= j$\;
            \While{\Ancestor{$r$} $\neq 0$ {\bf and} \Ancestor{$r$} $\neq i$}{
              $t := $\Ancestor{$r$}\;
              $\Ancestor{$r$} := i$\;
              $r := t$\;
            }
            \If{\Ancestor{$r$} $== 0$}{
              \Ancestor{$r$} $:= i$\;
              \Parent{$r$} $:= i$\;
            }
          }
        }
      }
    \end{algorithm}
  \end{minipage}
  \captionof{algocf}{ Vylepšený algoritmus pro hledání eliminačního stromu (\cite{liu:86}, upraveno) \label{eltree2Algorithm}}
\end{figure}


Složitost Algoritmu \ref{eltree2Algorithm} lze seshora odhadnout jako $O(|E|\log_2 n)$ \cite{tar:75}. Existuje ještě efektivnější verze tohoto algoritmu, kterou můžeme nalézt v \cite{tar:83}.

Algoritmy uvedené v této kapitole jsou popsány tak, aby byly dostatečně názorné. Ve skutečnosti pro řídké matice uložené v CSR formátu (viz \ref{matrixProgReprez}) neprocházíme všechny prvky dané matice, ale pouze nenulové prvky uložené ve struktuře.

%----------------------------------------------------------------------

\chapter{Algoritmizace a implementace}

Cílem programu, který jsme implementovali, je analyzovat rozdělení grafu získané za pomoci profesionální numerické knihovny pro dělení grafů METIS a ukázat, že nemusí být vyvážené vzhledem k výpočtu Choleského rozkladu na vzniklých oblastech. Dále jsme testovali závislost kvality rozdělení vzhledem k Choleského rozkladu na očíslování grafu. Prozkoumali jsme, zda lze lehkou modifikací vrcholového separátoru dosáhnout zlepšení vyváženosti počtu operací potřebných pro Choleského rozklad na jednotlivých oblastech. Vzhledem k analytickému charakteru této práce jsme zvolili implementaci, která si neklade za cíl používat co nejefektivnější algoritmy, ale dává přednost dobré přehlednosti a názornosti programu.

V naší implementaci jsme se omezili na dělení grafu na dvě části pomocí vrcholového separátoru. Toto omezení nám přirozeně vyplynulo z implementace, jelikož knihovna METIS neposkytuje podprogram pro dělení grafu pomocí vrcholového separátoru na více než dvě části. Námi implementovaný kód je napsán obecně pro graf rozdělený na $k$ částí. Implementací jiného grafového děliče nebo použitím algoritmů pro převod hranového separátoru na vrcholový by tedy bylo možné výsledky rozšířit i pro dělení grafu na $k>2$ částí.

Námi implementovaný program se volá z příkazové řádky a jeho funkce závisí na argumentech, s nimiž je zavolán. Tyto argumenty budou popsány níže v odstavci \ref{cmdlineSection}. Základní struktura programu, která je nezávislá na tom, s jakými argumenty je zavolán, je následující. Nejprve dojde k načtení matice; datová struktura, v níž je tato matice uložena, popisuje zároveň i jí odpovídající graf. Ten je poté za použití profesionální knihovny pro dělení grafů METIS rozdělen na dva podgrafy pomocí vrcholového separátoru . Následně v hlavní smyčce programu probíhá samotné zpracování matice. Nejprve jsou za použití rozdělení získaného pomocí knihovny METIS vytvořeny CSR reprezentace podgrafů. Následně, pokud se jedná o poslední iteraci hlavní smyčky a je to požadováno, dojde k přečíslování vrcholů jednotlivých podgrafů. Dále je zkonstruován eliminační strom a s jeho pomocí určen počet nenulových prvků v Choleského faktorech matic odpovídajících jednotlivým podgrafům. Pokud je to požadováno, je přesunutím vrcholového separátoru vytvořeno nové rozdělení grafu odpovídajícího vstupní matici a hlavní smyčka spuštěna znovu. 

Náš program podporuje grafický výstup, který je vypsán v jazyce DOT a může být použit pro zobrazení grafu a jeho výsledného rozdělení pomocí knihovny Graphviz.

Program byl implementován v programovacím jazyce Fortran, pro použití knihovny METIS napsané v C++ jsme vytvořili rozhraní pro volání podprogramů napsaných v C++ z Fortranu. Pro opakované spouštění programu za účelem testování jsme používali skript napsaný v jazyce Python.

\TODO{github?}

\section{Formát a uložení vstupní matice}
V této podkapitole bude specifikován formát vstupní matice a způsob její reprezentace v programu.

\subsection{Podporované formáty vstupních matic}

Náš program pracuje s maticemi uloženými v souborech ve formátu Harwell-Boeing \cite{bopo:97}. Konkrétně je schopen zpracovat reálné symetrické matice ve formátech RSA a PSA. Tyto dva formáty mají navzájem si podobnou strukturu, ve formátu RSA jsou navíc uloženy i numerické hodnoty matice. Ty však v našem programu nebereme v úvahu, protože se nezabýváme výpočtem numerických hodnot v Choleského faktoru zpracovávané matice, ale pouze jeho strukturou. Popis kolekcí matic, z nichž jsme čerpali při testování našeho programu, lze nalézt například v \cite{ssmcol} a \cite{hbcol}. Tyto matice bývají standardně uloženy v souborech s příponou \texttt{.rsa} nebo \texttt{.rb}.

Pro testování jsme dále používali matice vygenerované při jednoduché pětibodové diskretizaci dvojrozměrné Poissonovy rovnice (podprogram \texttt{poisson}) a několik jednoduchých testovacích matic, které jsme si ručně vytvořili v souboru \texttt{testing.f90}. Tyto matice jsou uloženy nebo generovány v programu a jejich zpracování lze vyvolat pomocí argumentu \texttt{-mt} z příkazové řádky.

\subsection{Reprezentace matice v programu}
\label{matrixProgReprez}

Matice je v našem programu uložena v \textbf{CSR formátu} (compressed sparse row format) \cite{pis:84,saad:94}, který je běžně využívaným formátem sloužícím pro reprezentaci řídkých matic a grafů.

Popišme CSR formát pro řídkou matici $A$ o rozměrech $n \times n$, která obsahuje $n_e$ nenulových prvků. Tuto matici v programu reprezentujeme pomocí dvou polí: pole ukazatelů \texttt{ia} o délce $n+1$ a pole \texttt{ja} o délce $n_e$. Pro $i\in\{1,\ldots,n\}$ jsou v poli \texttt{ja} na pozicích \texttt{ia($i$)}, \ldots, \texttt{ia$(i+1)-1$} uloženy sloupcové indexy nenulových prvků na $i$-tém řádku matice $A$. Na odpovídajících pozicích v poli \texttt{aa} jsou uloženy numerické hodnoty těchto prvků.

\begin{example}
  \label{CSRexample}
  Mějme následující symetrickou matici
  \[
    \begin{pmatrix}
      0 & 5 & 0 & 3 & 0 \\
      5 & 0 & 9 & 4 & 2 \\
      0 & 9 & 0 & 0 & 0 \\
      3 & 4 & 0 & 0 & 4 \\
      0 & 2 & 0 & 4 & 0
    \end{pmatrix}
  \]
  Pak její reprezentace ve formátu CSR vypadá následovně:
  \begin{verbatim}
    ia = [ 1, 3, 7, 8, 11, 13 ]
    ja = [ 2, 4, 1, 3, 4, 5, 2, 1, 2, 5, 2, 4 ]
    aa = [ 5, 3, 5, 9, 4, 2, 9, 3, 4, 4, 2, 4 ]
  \end{verbatim}
\end{example}

Vzhledem k tomu, že v našem programu pracujeme pouze se strukturou matice, můžeme při reprezentaci matice vynechat pole $\texttt{aa}$. Zřejmě je pak výsledná reprezentace matice $A$ zároveň reprezentací neorientovaného grafu, kterému matice $A$ odpovídá a můžeme tedy při popisu implementace bez újmy na obecnosti pojmy graf a matice zaměňovat.

\begin{example}
  Vezměme matici z Příkladu \ref{CSRexample}. Pak graf, který je reprezentován pomocí polí \texttt{ia}, \texttt{ja} je zobrazen na obrázku \ref{prGrMat}
\end{example}

\section{Knihovna METIS pro dělení grafu}

Pro samotné dělení grafu na dvě části jsme využili knihovnu pro dělení grafů METIS \cite{kary:13} verze 5.1.0. Vzhledem k tomu, že jsme dělení grafů používali jako nástroj pro vyvažování počtu operací při Choleského rozkladu na jednotlivých oblastech, potřebovali jsme nalézt rozdělení grafu pomocí vrcholového separátoru. Takové rozdělení nám poskytne podprogram \texttt{METIS\_ComputeVertexSeparator}, který jsme ve Fortranu implementovali pomocí rozhraní \texttt{metis\_interface.f95} a \texttt{metisinclude.c} převzatých z \cite{klforum1}

Zmíněný podprogram není popsán v oficiální dokumentaci knihovny METIS a není tedy ve své základní verzi kompatibilní s jazykem Fortran. Proto bylo nutné učinit několik změn ve formátu CSR tak, aby bylo možné podprogram použít. Nejprve bylo třeba odebrat z grafu smyčky a poté jej přečíslovat tak, aby byly vrcholy indexovány od 0, jak je požadováno v jazycích C a C++.

Výstupem podprogramu \texttt{METIS\_ComputeVertexSeparator} je pole \texttt{part} o délce rovné počtu vrcholů grafu. Na $i$-té pozici tohoto pole je číslo od $1$ do $3$ (po převedení do indexování od $1$ používaného v jazyce Fortran). To určuje, ve které části rozdělení se daný vrchol nachází. Pro vrchol s indexem $j$, který náleží do vrcholového separátoru, je \texttt{part}$[j] = 3$.

\section{Tvorba podgrafů}
Pro tvorbu podgrafů při znalosti vstupního rozdělení jsme použili námi napsaný podprogram \texttt{createSubgraphs}. Hlavní princip tohoto podprogramu lze popsat následovně. Jejho vstupem je graf v CSR formátu a vektor \texttt{part} popisující rozdělení tohoto grafu. Výstupem tohoto podprogramu jsou jednotlivé podgrafy popsané pomocí vektoru \texttt{part} uložené v CSR formátech. Pro snadnou manipulaci s těmito podgrafy je ukládáme do dvou datových struktur \texttt{iap} a \texttt{jap}. Formát těchto datových struktur je definován v \texttt{raggedmultiarray.f90} a byl převzat z \cite{ragmult}. $i$-tý podgraf ja pak uložen v polích \texttt{iap\%vectors($i$)\%elements}, \texttt{jap\%vectors($i$)\%elements}.


\section{Číslování}
V našem programu jsme implementovali 4 způsoby číslování vrcholů,mezi nimiž lze přepínat pomocí argumentu \texttt{-ot} z příkazové řádky.

První metodou, kterou jsme implementovali, je číslování vrcholů grafu v závislosti na vzdálenosti od separátoru popsané v kapitole \ref{sepDistOrdering}. Jedná se o podprogram \texttt{orderByDistance}. Druhou implementovanou metodou je číslování vrcholů pomocí metody minimálního stupně popsané v odstavci \ref{MDordering}. Tuto metodu jsme implementovali jako podprogram \texttt{orderByMD}. Třetí a čtvrtá metoda obsažená v našem programu používá smíšené číslování popsané v kapitole \ref{Mixedordering}. Podprogram \texttt{orderMixed} čísluje vrcholy na základě kombinace kritérií metody minimálního stupně a metody maximální vzdálenosti od separátoru. Naproti tomu v podprogramu \texttt{orderCoefMixed} je zvlášť napočítáno číslování v závislosti na vzdálenosti od separátoru a číslování pomocí metody minimálního stupně. Poté dojde k jejich konvexní kombinaci s koeficientem $C \in [0,1]$, který je vstupním parametrem tohoto podprogramu.

Výstupem všech výše zmíněných podprogramů jsou vektory \texttt{ordperm} a \texttt{invordperm} popisující nově získanou permutaci vrcholů.

Číslování vždy aplikujeme na původní graf a poté ho pomocí podprogramů \texttt{partOrdering} a \texttt{applyOrdering} projektujeme na podgrafy získané dříve. Tím je zajištěno, že metody používající číslování pomocí metody minimálního stupně budou brát v potaz hrany, které spojují vrcholy v jednotlivých částech s vrcholy ve vrcholovém separátoru.

V podprogramech pro číslování vrcholů jsme využívali pro řazení vrcholů podprogram \texttt{MRGRNK} z knihovny Orderpack 2.0 \cite{orderpack}.

\section{Tvorba eliminačního stromu a výpočet Choleského rozkladu}
Tvorbu eliminačního stromu a následný výpočet Choleského rozkladu provádíme pro každý podgraf zvlášť. Abychom zjistili počet prvků v Choleského faktoru matice, potřebujeme nejprve pomocí Algoritmu \ref{eltree2Algorithm} popsaného v oddíle \ref{EltreeAlgSection} sestrojit eliminační strom odpovídající matice. Pro tvorbu eliminačního jsme použili podprogram \texttt{eltree2}. Poté jsme pomocí podprogramu \texttt{colcnts}  využívající Algoritmus \ref{nonzerosAlgorithm} vypočítali počet nenulových prvků v jednotlivých sloupcích Choleského faktoru matice a sečtením těchto hodnot jsme dostali výsledný počet nenulových prvků. Podprogramy \texttt{eltree2} a \texttt{colcnts} jsme převzali z \cite{lapack}.

Podprogram \texttt{colcnts} nezahrnuje do počtu prvků v Choleského faktoru diagonální prvky matice. Ty však pro celkový výsledek nejsou důležité, protože na diagonále nemůže dojít ke vzniku zaplnění.

\section{Přesun vrcholového separátoru}
K přesunu vrcholového separátoru dojde pouze v případě, že si jej uživatel našeho programu explicitně vyžádá při volání programu z příkazové řádky pomocí argumentu \texttt{-mvs}. Přesun vrcholového separátoru je používán jako nástroj pro vyvážení počtu nenulových prvků v Choleského faktorech jednotlivých částí rozdělení. Proto je vrcholový separátor vždy přesouván směrem do části, v níž je zaplnění nejvyšší.

Označme $G_{max}$ část rozdělení s největším zaplněním v Choleského faktoru. Pro přesun vrcholového separátoru $S$ jsme použili jednoduchý způsob, kdy přidáme k vrcholovému separátoru $(G_{max} \cap\mathrm{adj}(S))$. Následně z něj ubereme vrcholy, které ve vrcholovém separátoru původně byly, ale přidáním $(G_{max} \cap\mathrm{adj}(S))$ v něm ztratily svůj význam.

Zřejmě tímto postupem může dojít u obecného grafu k výraznému zvětšení velikosti vrcholového separátoru. V běžných aplikacích by však toto zvětšení nemělo být natolik výrazné, aby nedávalo smysl přesun vrcholového separátoru prozkoumat.


\section{Volání programu z příkazové řádky}
\label{cmdlineSection}

Při volání našeho programu z příkazové řádky je třeba mu poskytnout informace o tom jakou matici a jakým způsobem má program zpracovat. K tomu slouží argumenty, s nimiž může být program volán, které jsou blíže popsány v Tabulce \ref{cmdArgTable}. Argumenty, s nimiž je program volán, jsou čteny zleva doprava. Pokud tedy program zpracuje argument, který není ve správném tvaru, další argumenty již nezpracovává a vypíše chybové hlášení.

\bigskip
{\noindent
\footnotesize
  \centering
  \renewcommand{\arraystretch}{1.15}
\begin{tabular}{|l|c|p{8cm}|}
  \hline
  \multicolumn{1}{|c|}{Argument}    & \multicolumn{1}{c|}{Priorita} & \multicolumn{1}{c|}{Funkce} \\
  \hline
  \texttt{-mt [matrixtype]}  & 2 & Používá se pro nastavení typu vstupní matice. Parametr \texttt{matrixtype} je povinný a jeho možné hodnoty jsou \texttt{RSA} pro matici načítanou ze souboru, \texttt{P[number]} pro matici o rozměrech \texttt{number}$\times$\texttt{number} vzniklou při jednoduché pětibodové diskretizaci dvojrozměrné Poissonovy rovnice, \texttt{T[number]} pro testovací matici s indexem \texttt{number} popsanou v souboru \texttt{testing.f90}. Tento argument je povinný, pokud není použit argument \texttt{-f}. \\
  \texttt{-f [path]}& 3 & Slouží k nastavení cesty (\texttt{path}) ke vstupnímu souboru matice. Tento argument je ignorován, pokud je použit argument \texttt{-mt} s parametrem \texttt{P[number]} nebo \texttt{T[number]}, v opačném případě je povinný.\\
  \texttt{-ot [orderingtype]}& 2 & Využívá se pro nastavení metody číslování vrcholů. Možné hodnoty povinného parametru \texttt{orderingtype} jsou \texttt{DIST} pro číslování vrcholů grafu v závislosti na vzdálenosti od separátoru, \texttt{MD} pro číslování vrcholů pomocí metody minimálního stupně, \texttt{MIX} pro číslování pomocí smíšeného číslování používajícího současně metodu minimálního stupně a vzdálenost od separátoru a \texttt{MIX[number]} pro konvexní kombinaci těchto očíslování s koeficientem \texttt{number}~$ \in [0,1]$. Pokud není argument \texttt{-ot} uveden, nedojde k žádnému přeuspořádání vrcholů v částech. \\
  \texttt{-mvs [number]}& 2 & Slouží k nastavení počtu přesunů vrcholového separátoru směrem do části rozdělení s větším zaplněním. Parametr \texttt{number} je povinný a může nabývat hodnot $0 - 20$. Pokud není argument použit, k přesunu vrcholového separátoru nedojde. \\
  \texttt{-oe}& 3 & Pokud je tento argument uveden, dochází k číslování vrcholů pomocí číslování nastaveného za pomoci argumentu \texttt{-ot} v každé iteraci hlavní smyčky, v opačném případě pouze v poslední. Pokud nejsou použity zárověň argumenty \texttt{-ot} a \texttt{-mvs}, nemá tento argument žádný vliv na běh programu.\\
  \texttt{-o [path]}& 2 & Slouží se pro vytvoření výstupního souboru ve formátu, který lze zobrazit pomocí softwarové knihovny Graphviz. Parametr \texttt{path} slouží k nastavení cesty k výstupnímu souboru. Pokud soubor již existuje, bude přepsán. Pokud argument není použit, k vypsání výstupu nedojde.\\
  \texttt{-w}& 2 & Pokud je tento argument použit, program v průběhu svého běhu vypisuje informaci o tom, která jeho část právě probíhá. \\
  \texttt{-h}& 1 & Pokud je tento argument použit, jsou všechny ostatní argumenty ignorovány a je pouze vypsána nápověda k programu. \\
  \hline
\end{tabular}
\captionof{table}{Popis argumentů programu při volání z příkazové řádky \label{cmdArgTable}}
}

%----------------------------------------------------------------------
\chapter{Výsledky}

\section{Informace o systému}
Náš program byl testován na MacBook Pro (Retina, 15-inch, Mid 2015) s procesorem 2,5 GHz Intel Core i7, operační pamětí 16GB 1600 MHz DDR3 a grafickou kartou Intel Iris Pro 1536 MB.

Pro úspěšné zkompilování a zlinkování projektu je třeba mít nainstalovaný GNU Make (testováno na verzi 3.81), gcc a gfortran (testováno pro verzi 6.3.0) a dělič grafů METIS (testováno pro verzi 5.1.0). Pro zobrazování výsledných grafů je třeba mít nainstalovanou knihovnu Graphviz, konkrétně jsme používali dot~-~graphviz version 2.40.1 \cite{graphviz}.

\section{Výsledky pro základní typy číslování}
\label{numberingResultsSection}
V této podkapitole porovnáme počet nenulových prvků v Choleského faktoru v závislosti na zvoleném typu číslování bez toho, aby došlo k přesunu vektorového separátoru. Pro soubor 110 námi testovaných matic jsme spustili program se čtyřmi různými nastaveními. Nejprve bez toho, aby se vrcholy jakkoliv přečíslovávaly, poté jsme vrcholy číslovali podle jejich vzdálenosti od vrcholového separátoru. Dále jsme použili číslování pomocí metody minimálního stupně a smíšené číslování používající kritérium kombinující obě předchozí. V Tabulce \ref{resultTable} jsou vypsány výsledky pro reprezentativní podmnožinu matic, které jsme testovali. 

\bigskip
{\noindent
\footnotesize
  \centering
  \renewcommand{\arraystretch}{1.1}
\begin{longtable}{|l|c|c|c|r|r|r|}
  \hline
  \multicolumn{1}{|c|}{Matice} & \multicolumn{1}{|c|}{$|S|$}    &\multicolumn{1}{|c|}{$|V_1|$} &\multicolumn{1}{|c|}{$|V_2|$} & \multicolumn{1}{|c|}{\texttt{-ot}} & \multicolumn{2}{c|}{Počty nenul} \\
  \hline
  \multirow{4}{*}{P50}
    &	\multirow{4}{*}{50}	&	\multirow{4}{*}{1225}	&	\multirow{4}{*}{1225}	&\texttt{-} &	28718	&	29419	\\
    &	&	&	&\texttt{DIST} &	50510	&	54393	\\
    &	&	&	&\texttt{MD} &	15282	&	14367	\\
    &	&	&	&\texttt{MIX} &	14233	&	14936	\\
    \hline
  \multirow{4}{*}{P100}
    &	\multirow{4}{*}{100}	&	\multirow{4}{*}{4950}	&	\multirow{4}{*}{4950}	&\texttt{-}&	241249	&	240331	\\
    &	&	&	&\texttt{DIST}&	461142	&	465406	\\
    &	&	&	&\texttt{MD}&	89757	&	91915	\\
    &	&	&	&\texttt{MIX}&	91152	&	89384	\\
    \hline
  \multirow{4}{*}{1138\_bus.rb}
    &	\multirow{4}{*}{5}	&	\multirow{4}{*}{653}	&	\multirow{4}{*}{480}	&\texttt{-}    &	14529	&	7876	\\
    & & & &\texttt{DIST} &	2361	&	1251	\\
    & & & &\texttt{MD}   &	1215	&	783	\\
    & & & &\texttt{MIX}  &	1227	&	782	\\
    \hline
  \multirow{4}{*}{685\_bus.rb	}
    &	\multirow{4}{*}{8}	&	\multirow{4}{*}{378}	&	\multirow{4}{*}{299}	&\texttt{-}    &	7418	&	4820	\\
    & & & &\texttt{DIST} &	5296	&	1802	\\
    & & & &\texttt{MD}   &	1733	&	1011	\\
    & & & &\texttt{MIX}  &	1716	&	1013	\\
    \hline
  \multirow{4}{*}{bcspwr07.rb	}
    &	\multirow{4}{*}{6}	&	\multirow{4}{*}{843}	&	\multirow{4}{*}{763}	&\texttt{-}    &	7662	&	10542	\\
    & & & &\texttt{DIST} &	4178	&	3751	\\
    & & & &\texttt{MD}   &	1817	&	1716	\\
    & & & &\texttt{MIX}  &	1833	&	1689	\\
    \hline
  \multirow{4}{*}{bcspwr09.rb	}
    &	\multirow{4}{*}{7}	&	\multirow{4}{*}{858}	&	\multirow{4}{*}{858}	&\texttt{-}    &	2172	&	2756	\\
    & & & &\texttt{DIST} &	4563	&	6797	\\
    & & & &\texttt{MD}   &	2041	&	2261	\\
    & & & &\texttt{MIX}  &	2017	&	2313	\\
    \hline
  \multirow{4}{*}{bcsstk01.rsa	}
    &	\multirow{4}{*}{12}	&	\multirow{4}{*}{18}	&	\multirow{4}{*}{18}	&\texttt{-}    &	105	&	113	\\
    & & & &\texttt{DIST} &	113	&	115	\\
    & & & &\texttt{MD}   &	75	&	75	\\
    & & & &\texttt{MIX}  &	75	&	75	\\
    \hline
  \multirow{4}{*}{bcsstk05.rb	}
    &	\multirow{4}{*}{12}	&	\multirow{4}{*}{69}	&	\multirow{4}{*}{72}	&\texttt{-}    &	952	&	999	\\
    & & & &\texttt{DIST} &	813	&	1041	\\
    & & & &\texttt{MD}   &	761	&	1101	\\
    & & & &\texttt{MIX}  &	761	&	1020	\\
    \hline
  \multirow{4}{*}{bcsstk07.rsa	}
    &	\multirow{4}{*}{36}	&	\multirow{4}{*}{195}	&	\multirow{4}{*}{189}	&\texttt{-}    &	4983	&	5094	\\
    & & & &\texttt{DIST} &	5372	&	5149	\\
    & & & &\texttt{MD}   &	3929	&	3764	\\
    & & & &\texttt{MIX}  &	3975	&	4047	\\
    \hline
  \multirow{4}{*}{bcsstk08.rb	}
    &	\multirow{4}{*}{57}	&	\multirow{4}{*}{564}	&	\multirow{4}{*}{453}	&\texttt{-}    &	50962	&	44817	\\
    & & & &\texttt{DIST} &	82463	&	43983	\\
    & & & &\texttt{MD}   &	10735	&	9304	\\
    & & & &\texttt{MIX}  &	10291	&	8895	\\
    \hline
  \multirow{4}{*}{bcsstk09.rb	}
    &	\multirow{4}{*}{57}	&	\multirow{4}{*}{513}	&	\multirow{4}{*}{513}	&\texttt{-}    &	14989	&	14995	\\
    & & & &\texttt{DIST} &	27949	&	27955	\\
    & & & &\texttt{MD}   &	20882	&	21590	\\
    & & & &\texttt{MIX}  &	20924	&	20793	\\
    \hline
  \multirow{4}{*}{bcsstk10.rb	}
    &	\multirow{4}{*}{3}	&	\multirow{4}{*}{651}	&	\multirow{4}{*}{432}	&\texttt{-}    &	13610	&	5970	\\
    & & & &\texttt{DIST} &	13736	&	5970	\\
    & & & &\texttt{MD}   &	15358	&	6758	\\
    & & & &\texttt{MIX}  &	15331	&	6758	\\
    \hline
  \multirow{4}{*}{bcsstk12.rb	}
    &	\multirow{4}{*}{33}	&	\multirow{4}{*}{704}	&	\multirow{4}{*}{736}	&\texttt{-}    &	30577	&	42640	\\
    & & & &\texttt{DIST} &	30406	&	33019	\\
    & & & &\texttt{MD}   &	22193	&	25807	\\
    & & & &\texttt{MIX}  &	20915	&	24406	\\
    \hline
  \multirow{4}{*}{bcsstk13.rb	}
    &	\multirow{4}{*}{182}	&	\multirow{4}{*}{1173}	&	\multirow{4}{*}{648}	&\texttt{-}    &	145761	&	74093	\\
    & & & &\texttt{DIST} &	256734	&	76024	\\
    & & & &\texttt{MD}   &	132352	&	48193	\\
    & & & &\texttt{MIX}  &	134707	&	45573	\\
    \hline
  \multirow{4}{*}{bcsstk14.rsa	}
    &	\multirow{4}{*}{84}	&	\multirow{4}{*}{862}	&	\multirow{4}{*}{860}	&\texttt{-}    &	50448	&	48812	\\
    & & & &\texttt{DIST} &	78327	&	76977	\\
    & & & &\texttt{MD}   &	44011	&	43834	\\
    & & & &\texttt{MIX}  &	42359	&	41790	\\
    \hline
  \multirow{4}{*}{bcsstk15.rb	}
    &	\multirow{4}{*}{180}	&	\multirow{4}{*}{2027}	&	\multirow{4}{*}{1741}	&\texttt{-}    &	396378	&	267754	\\
    & & & &\texttt{DIST} &	481233	&	370617	\\
    & & & &\texttt{MD}   &	294829	&	223494	\\
    & & & &\texttt{MIX}  &	287343	&	238666	\\
    \hline
  \multirow{4}{*}{bcsstk17.rb	}
    &	\multirow{4}{*}{138}	&	\multirow{4}{*}{4366}	&	\multirow{4}{*}{6470}	&\texttt{-}    &	428589	&	853932	\\
    & & & &\texttt{DIST} &	493182	&	1302456	\\
    & & & &\texttt{MD}   &	307119	&	749462	\\
    & & & &\texttt{MIX}  &	313716	&	666343	\\
    \hline
  \multirow{4}{*}{bcsstk18.rb	}
    &	\multirow{4}{*}{182}	&	\multirow{4}{*}{6283}	&	\multirow{4}{*}{5483}	&\texttt{-}    &	1271033	&	640943	\\
    & & & &\texttt{DIST} &	1684137	&	864894	\\
    & & & &\texttt{MD}   &	335191	&	172683	\\
    & & & &\texttt{MIX}  &	346314	&	187524	\\
    \hline
  \multirow{4}{*}{bcsstk21.rb	}
    &	\multirow{4}{*}{0}	&	\multirow{4}{*}{1800}	&	\multirow{4}{*}{1800}	&\texttt{-}    &	104902	&	105443	\\
    & & & &\texttt{DIST} &	104902	&	105443	\\
    & & & &\texttt{MD}   &	45186	&	45186	\\
    & & & &\texttt{MIX}  &	45186	&	45186	\\
    \hline
  \multirow{4}{*}{bcsstk23.rb	}
    &	\multirow{4}{*}{272}	&	\multirow{4}{*}{1165}	&	\multirow{4}{*}{1697}	&\texttt{-}    &	146117	&	285543	\\
    & & & &\texttt{DIST} &	207121	&	378605	\\
    & & & &\texttt{MD}   &	98223	&	177520	\\
    & & & &\texttt{MIX}  &	85133	&	187168	\\
    \hline
  \multirow{4}{*}{bcsstk25.rb	}
    &	\multirow{4}{*}{162}	&	\multirow{4}{*}{7168}	&	\multirow{4}{*}{8109}	&\texttt{-}    &	1400436	&	1431953	\\
    & & & &\texttt{DIST} &	1192351	&	1477772	\\
    & & & &\texttt{MD}   &	757791	&	783610	\\
    & & & &\texttt{MIX}  &	667338	&	773560	\\
    \hline
  \multirow{4}{*}{bcsstk26.rb	}
    &	\multirow{4}{*}{71}	&	\multirow{4}{*}{924}	&	\multirow{4}{*}{927}	&\texttt{-}    &	36309	&	22181	\\
    & & & &\texttt{DIST} &	53153	&	40456	\\
    & & & &\texttt{MD}   &	18159	&	13454	\\
    & & & &\texttt{MIX}  &	18762	&	13213	\\
    \hline
  \multirow{4}{*}{bcsstk28.rb	}
    &	\multirow{4}{*}{66}	&	\multirow{4}{*}{2571}	&	\multirow{4}{*}{1773}	&\texttt{-}    &	381960	&	150312	\\
    & & & &\texttt{DIST} &	527473	&	234238	\\
    & & & &\texttt{MD}   &	207732	&	118908	\\
    & & & &\texttt{MIX}  &	204384	&	113328	\\
    \hline
  \multirow{4}{*}{bcsstk30.rb	}
    &	\multirow{4}{*}{209}	&	\multirow{4}{*}{16707}	&	\multirow{4}{*}{12008}	&\texttt{-}    &	10846819	&	4571992	\\
    & & & &\texttt{DIST} 	&	11259063	&	5119425	\\
    & & & &\texttt{MD}		& 2854234   & 1527204	\\
    & & & &\texttt{MIX}		&	2690415		& 1545013 \\
  \hline
\end{longtable}
\captionof{table}{Porovnání počtu nenulových prvků v Choleského faktorech pro různé typy číslování \label{resultTable}}
}
\bigskip

Z Tabulky \ref{resultTable} je vidět, že ve valné většině případů nám již samotné očíslování vrcholů může výrazně pomoci redukovat zaplnění v Choleského faktoru matice. Ukazuje se, že číslování podle vzdálenosti od separátoru není pro tuto úlohu příliš vhodné, jen v několika případech s jeho pomocí došlo k výraznému zmenšení počtu nenulových prvků v Choleského rozkladech matice. Naproti tomu metoda minimálního stupně a smíšené číslování nám pro většinu matic poskytnou výrazné zlepšení. V případech, kdy pomocí žádného číslování nezískáme lepší výsledky než byly výsledky bez něj, obvykle nedochází k výrazné degradaci.

Můžeme pozorovat, že v některých případech je při použití dvou různých očíslování rozdíl v tom, ve které části rozdělení je větší počet nenulových prvků. Vzhledem k tomu, že na tuto informaci bereme ohled při přesouvání vrcholového separátoru, je vhodné vrcholy grafu očíslovat námi zvoleným číslováním před každým přesunutím vrcholového separátoru a ne jen v poslední iteraci. To nám však výrazně přidá na výpočetní náročnosti, a proto v kapitole \ref{mvswithNumbering} diskutujeme, zda tento postup přináší lepší výsledky.

\subsection{Výsledky pro smíšené číslování s konvexní kombinací}

Popišme nyní smíšené číslování, kdy je zvlášť napočítáno číslování v závislosti na vzdálenosti od separátoru a pomocí metody minimálního stupně a poté dojde ke konvexní kombinaci těchto očíslování s koeficientem z intervalu $[0,1]$. Pro koeficient $0$ je výsledek tohoto číslování roven výsledku metody minimálního stupně, pro koeficient $1$ výsledku číslování podle vzdálenosti od separátoru.

V Tabulce \ref{mixCoefResultTable} je pro koeficienty $0, 0.1,\ldots,0.9, 1$ zanesen počet nenulových prvků v Choleského faktoru. Je vidět, že tato metoda číslování nám nic nového nepřinese. Oproti číslování podle vzdálenosti od separátoru dojde ke zlepšení pouze ve výjimečných případech, oproti číslování pomocí metody minimálního stupně jsme zlepšení nepozorovali ani jednou. Testy byly z důvodu výpočetní náročnosti prováděny pro matice menších rozměrů. Lze však předpokládat, že pro velké matice by dopadly obdobně.

\bigskip
{\noindent
\scriptsize
  \centering
  \renewcommand{\arraystretch}{1.1}
  \setlength{\tabcolsep}{0.25em}
\begin{tabular}{|l|rrrrrrrrrrr|}
  \hline
  Matice \textbackslash \texttt{-ot}& \texttt{MD} & \texttt{MIX0.1} & \texttt{MIX0.2} & \texttt{MIX0.3} & \texttt{MIX0.4} & \texttt{MIX0.5} & \texttt{MIX0.6} & \texttt{MIX0.7} & \texttt{MIX0.8} & \texttt{MIX0.9} & \texttt{DIST} \\
  \hline
  \multirow{2}{*}{P50}&15282&103234&121152&109359&111812&118094&112497&99655&109074&119051&50510	\\
  &14367&108575&112733&115630&102834&103356&114932&98437&115937&106708&54393	\\
  \hline
  \multirow{2}{*}{P100}&89757&1809102&1676651&1710096&1758236&1889922&1710749&1703777&1541943&1842054&461142	\\
  &91915&1787391&1862763&1873276&1848251&1785686&1788840&1843698&1753333&1828004&465406	\\
  \hline
  \multirow{2}{*}{1138\_bus.rb}&1215&11055&16242&13029&13274&14298&16641&11413&12395&7210&2361	\\
  &783&4387&8274&9067&6301&7359&7563&3642&4449&3490&1251	\\
  \hline
  \multirow{2}{*}{685\_bus.rb}&1733&10087&10036&9938&9536&6252&12605&9812&12374&6276&5296	\\
  &1011&3695&3428&4219&3480&3390&3802&3964&4423&4415&1802	\\
  \hline
  \multirow{2}{*}{bcspwr07.rb}&1817&14112&17179&18798&15370&16954&11777&18305&10723&9906&4178	\\
  &1716&13822&15877&15620&15893&14149&17023&28831&15288&20222&3751	\\
  \hline
  \multirow{2}{*}{bcspwr08.rb}&1749&13269&15131&16966&15130&14426&19179&14292&12648&12207&5438	\\
  &2026&22132&22724&16782&26091&16473&14874&19211&18856&14661&6169	\\
  \hline
  \multirow{2}{*}{bcspwr09.rb}&2041&3113&3204&3665&5269&4744&6220&8230&10144&9239&4563	\\
  &2261&4275&4796&4819&4137&5699&7176&6910&8753&13761&6797	\\
  \hline
  \multirow{2}{*}{bcspwr10.rb}&7811&10881&15530&22956&26125&42405&46642&82679&98621&90853&27669	\\
  &13773&18128&24115&27314&33601&40464&50899&59561&87708&112655&84444	\\
  \hline
  \multirow{2}{*}{bcsstk01.rsa}&75&86&91&114&91&86&121&101&100&118&113	\\
  &75&79&115&96&97&104&98&95&97&98&115	\\
  \hline
  \multirow{2}{*}{bcsstk05.rb}&761&1235&1545&1583&1549&1393&1218&1257&1222&1018&813	\\
  &1101&1572&1818&1893&1814&1875&1801&2184&1867&1556&1041	\\
  \hline
  \multirow{2}{*}{bcsstk07.rsa}&3929&12023&10153&11189&10204&10413&11500&11389&11978&11173&5372	\\
  &3764&10357&10545&10170&10360&10977&10043&10109&9824&9139&5149	\\
  \hline
  \multirow{2}{*}{bcsstk08.rb}&10735&65616&67604&67094&60477&70623&63393&59777&61775&58583&82463	\\
  &9304&49128&40621&48283&52451&54077&53235&51453&56609&53070&43983	\\
  \hline
  \multirow{2}{*}{bcsstk09.rb}&20882&74577&79299&79354&70839&82346&79389&76076&73929&81458&27949	\\
  &21590&72697&83707&75242&78370&74032&82074&77446&82159&69873&27955	\\
  \hline
  \multirow{2}{*}{bcsstk10.rb}&15358&141514&86564&118740&119000&119772&122533&111003&126876&123292&13736	\\
  &6758&48496&36154&41375&28273&39102&40291&35592&26696&34093&5970	\\
  \hline
  \multirow{2}{*}{bcsstk11.rsa}&22193&117188&133395&116290&131562&115183&115559&106653&79937&56042&30406	\\
  &25807&154017&164612&157651&179167&162179&162929&172767&154077&89407&33019	\\
  \hline
  \multirow{2}{*}{bcsstk12.rb}&22193&117188&133395&116290&131562&115183&115559&106653&79937&56042&30406	\\
  &25807&154017&164612&157651&179167&162179&162929&172767&154077&89407&33019	\\
  \hline
\end{tabular}
\captionof{table}{Počet nenulových prvků v Choleského faktoru při použití smíšeného číslování. \label{mixCoefResultTable}}
}

\section{Přesouvání vrcholového separátoru}

Již z podstaty Choleského rozkladu je zřejmé, že přidáním vrcholů ke grafu nemůže dojít ke snížení počtu nenulových prvků v Choleského faktoru matice sousednosti tohoto grafu. Proto námi navrženým přesouváním vrcholového separátoru není možné výrazně snížit počet nenulových prvků ve faktorech, pokud je tento počet vyvážený. Příklad takovéto situace můžeme vidět v Tabulce \ref{mvsTable1}. Zároveň je třeba vzít na vědomí, že pro speciální třídy grafů tento postup může být nevhodný, protože může dojít k výraznému zvětšení vrcholového separátoru a tím zvýšení výsledného času potřebného pro běh algoritmu i přesto, že počet operací potřebný pro výpočet Choleského rozklady v jednotlivých částech rozdělení bude menší než před přesunutím.

\bigskip
{\noindent
  \footnotesize
  \centering
  \renewcommand{\arraystretch}{1.1}
\begin{tabular}{|l|c|c|r|r|r|r|r|}
  \hline
  \multicolumn{1}{|c|}{Matice} & \multicolumn{1}{|c|}{\texttt{-ot}}  &\multicolumn{1}{|c|}{\texttt{-mvs}} &\multicolumn{1}{|c|}{$|S|$} & \multicolumn{1}{|c|}{$|V_1|$}& \multicolumn{1}{|c|}{$|V_2|$} & \multicolumn{2}{c|}{Počty nenul} \\
  \hline
    \multirow{10}{*}{bcsstk05.rb}
      & \multirow{10}{*}{\texttt{-}} & 0
      & 12	&	69	&	72	& 952 & 999 \\
      & & 1 
      &	12	&	81	&	60	&	1188	&	798	\\
      & & 2
      &	12	&	69	&	72	&	952	&	999	\\
      & & 3
      &	12	&	81	&	60	&	1188	&	798	\\
      & & 4
      &	12	&	69	&	72	&	952	&	999	\\
      & & 5
      &	12	&	81	&	60	&	1188	&	798	\\
      & & 6
      &	12	&	69	&	72	&	952	&	999	\\
      & & 7
      &	12	&	81	&	60	&	1188	&	798	\\
      & & 8
      &	12	&	69	&	72	&	952	&	999	\\
      & & 9
      &	12	&	81	&	60	&	1188	&	798	\\
    \hline
    \multirow{10}{*}{bcsstk08.rb}
      & \multirow{10}{*}{\texttt{-}} & 0
      & 57  & 564 & 453 &	50962	&	44817 \\
      & & 1 
      &	247	&	159	&	668	&	3189	&	96258	\\
      & & 2
      &	75	&	517	&	482	&	43155	&	47129	\\
      & & 3
      &	194	&	651	&	229	&	101880	&	4822	\\
      & & 4
      &	58	&	572	&	444	&	53938	&	44043	\\
      & & 5
      &	247	&	159	&	668	&	3189	&	96258	\\
      & & 6
      &	75	&	517	&	482	&	43155	&	47129	\\
      & & 7
      &	194	&	651	&	229	&	101880	&	4822	\\
      & & 8
      &	58	&	572	&	444	&	53938	&	44043	\\
      & & 9
      &	247	&	159	&	668	&	3189	&	96258	\\
  \hline
\end{tabular}
\captionof{table}{Příklad chování pro vyvážená rozdělení. \label{mvsTable1}}
}
\bigskip

Zřejmě při přesouvání vrcholového separátoru dojde od jisté chvíle k zacyklení, protože vrcholový separátor je přesouván vždy směrem do části s vyšším počtem prvků. Pro námi testované matice se periodické chování vyskytlo vždy dříve než v deváté iteraci algoritmu. Perioda nemusí být nutně rovna dvěma, jak by se člověk mohl domnívat. Příklad periodického chování algoritmu můžeme opět vidět v Tabulce \ref{mvsTable1}.

Námi zvolený algoritmus pro přesouvání vrcholů taktéž není vhodný pro grafy s velmi malým počtem vrcholů, protože u grafů tohoto typu často dojde přesunutím separátoru výrazné změně velikostí jednotlivých částí. To má za následek výraznou nevyváženost v počtu operací potřebných k výpočtu Choleského rozkladu příslušných podmatic. Tato situace může nastat i pro grafy se separátorem, který je v poměru k jednotlivým částem rozdělení velký. Jako příklad uveďme dva grafy popsané v Tabulce \ref{mvsTable2}

\bigskip
{\noindent
  \footnotesize
  \centering
  \renewcommand{\arraystretch}{1.15}
\begin{tabular}{|l|c|c|r|r|r|r|r|}
  \hline
  \multicolumn{1}{|c|}{Matice} & \multicolumn{1}{|c|}{\texttt{-ot}}  &\multicolumn{1}{|c|}{\texttt{-mvs}} &\multicolumn{1}{|c|}{$|S|$} & \multicolumn{1}{|c|}{$|V_1|$}& \multicolumn{1}{|c|}{$|V_2|$} & \multicolumn{2}{c|}{Počty nenul} \\
  \hline
    \multirow{7}{*}{bcsstk01.rsa}
      & \multirow{7}{*}{\texttt{-}} & 0
      & 12 & 18 & 18 & 105 & 113 \\
      & & 1  
      &	6	&	41	&	1	&	600	&	0	\\
      & & 2
      &	13	&	28	&	7	&	255	&	15	\\
      & & 3
      &	15	&	2	&	31	&	0	&	306	\\
      & & 4
      &	12	&	20	&	16	&	131	&	81	\\
      & & 5
      &	15	&	2	&	31	&	0	&	306	\\
      & & \vdots
      &	\vdots	&	\vdots	&	\vdots	&	\vdots	&	\vdots	\\
    \hline
    \multirow{4}{*}{bcsstk04.rsa}
      & \multirow{4}{*}{\texttt{-}} & 0
      &	24	&	54	&	54	&	1006	&	1100	\\
      & & 1   
      &	30	&	90	&	12	&	2138	&	60	\\
      & & 2
      &	24	&	54	&	54	&	1006	&	1100	\\
      & & \vdots
      &	\vdots	&	\vdots	&	\vdots	&	\vdots	&	\vdots	\\
    \hline
\end{tabular}
\captionof{table}{Příklad výrazné změny vyváženosti částí při přesunu vrcholového separátoru. \label{mvsTable2}}
}

Z předchozího textu by se mohlo zdát, že nám tato metoda přesunu separátoru nic nového nepřinese, ale není tomu tak. U matic, v nichž je počet prvků v jednotlivých Choleského faktorech po prvním rozdělení výrazně nevyvážený tato jednoduchá metoda výrazně pomáhá. V Tabulce \ref{mvsTable3} je pro reprezentativní podmnožinu testovacích matic zanesena informace o nejlepším dosaženém vyvážení počtu nenulových prvků v Choleského faktorech. Vidíme, že u nevyvážených rozdělení dochází v mnoha případech k zásadnímu zlepšení vyvážení rozdělení již po jedné nebo dvou iteracích. Zároveň je míra zvětšení velikosti vrcholového separátoru únosná. Závislost počtu nenulových prvků na použitém číslování popsaná v oddíle \ref{numberingResultsSection} se nemění ani při přesouvání separátoru.

\bigskip
{\noindent
  \footnotesize
  \centering
  \renewcommand{\arraystretch}{1.1}
\begin{tabular}{|l|c|c|r|r|r|r|r|}
  \hline
  \multicolumn{1}{|c|}{Matice} & \multicolumn{1}{|c|}{\texttt{-ot}}  &\multicolumn{1}{|c|}{\texttt{-mvs}} &\multicolumn{1}{|c|}{$|S|$} & \multicolumn{1}{|c|}{$|V_1|$}& \multicolumn{1}{|c|}{$|V_2|$} & \multicolumn{2}{c|}{Počty nenul} \\
	\hline
	\multirow{8}{*}{1138\_bus.rb}
	& \multirow{2}{*}{\texttt{-}}
  	& -	& 5	  & 653 & 480 & 14529	&	7876	\\
	& & 2	&	20	&	616	&	502	&	7103	&	9419	\\

  & \multirow{2}{*}{\texttt{DIST}}
  	& -	& 5	  & 653 & 480 &	2361	&	1251	\\
	& & 2	&	20	&	616	&	502	&	1645	&	1419	\\

  & \multirow{2}{*}{\texttt{MD}}
	  & -	& 5	  & 653 & 480 &	1215	&	783 \\
	& & 2	&	20	&	616	&	502	&	1011	&	860	\\

	& \multirow{2}{*}{\texttt{MIX}}
  	& -	& 5	  & 653 & 480 &	1227	&	782 \\
	& & 2	&	20	&	616	&	502	&	1016	&	856	\\
\hline
\multirow{8}{*}{685\_bus.rb}
	& \multirow{2}{*}{\texttt{-}}
  	& -	&  8	& 378 & 299 & 7418	&	4820	\\
	& & 3	&	26	&	283	&	376	&	4756	&	5844	\\
	& \multirow{2}{*}{\texttt{DIST}}
  	& -	&  8	& 378 & 299 & 5296	&	1802	\\
	& & 3	&	26	&	283	&	376	&	3732	&	2770	\\
	& \multirow{2}{*}{\texttt{MD}}
  	& -	&  8	& 378 & 299 & 1733	&	1011	\\
	& & 3	&	26	&	283	&	376	&	1126	&	1291	\\
	& \multirow{2}{*}{\texttt{MIX}}
  	& -	&  8	& 378 & 299 & 1716	&	1013	\\
	& & 3	&	26	&	283	&	376	&	1140	&	1268	\\
\hline
\multirow{8}{*}{bcspwr07.rb}
	& \multirow{2}{*}{\texttt{-}}
  	& -	  & 6	& 843 & 763 & 7662	&	10542	\\
	& & 4	&	20	&	923	&	669	&	8539	&	7985	\\
	& \multirow{2}{*}{\texttt{DIST}}
  	& -	  & 6	& 843 & 763 & 4178	&	3751	\\
	& & 1 	&	9	&	851	&	752	&	4249	&	3672	\\
	& \multirow{2}{*}{\texttt{MD}}
  	& -	  & 6	& 843 & 763 & 1817	&	1716	\\
	& & 1 	&	9	&	851	&	752	&	1874	&	1671	\\
	& \multirow{2}{*}{\texttt{MIX}}
  	& -	  & 6	& 843 & 763 & 1833	&	1689	\\
	& & 1 	&	9	&	851	&	752	&	1876	&	1638	\\
\hline
\multirow{8}{*}{bcsstk13.rb}
	& \multirow{2}{*}{\texttt{-}}
  	& -	& 182	& 1173  & 648 & 145761	&	74093	\\
	& & 2	&	242	&	1071	&	690	&	122127	&	76158	\\
	& \multirow{2}{*}{\texttt{DIST}}
  	& -	& 182	& 1173  & 648  & 256734	&	76024	\\
	& & 1 &	409	&	503	  &	1091 &	65824	&	149162	\\
	& \multirow{2}{*}{\texttt{MD}}
  	& -	& 182	& 1173  & 648 & 132352	&	48193	\\
	& & 2	&	242	&	1071	&	690	&	109882	&	49759	\\
	& \multirow{2}{*}{\texttt{MIX}}
  	& -	& 182	& 1173  & 648  & 134707	&	45573	\\
	& & 1 &	409	&	503	  &	1091 &	31396	&	107946	\\
\hline
\multirow{8}{*}{bcsstk15.rb}
	& \multirow{2}{*}{\texttt{-}}
  	& -	  & 180	& 2027  & 1741 & 396378	&	267754	\\
	& & 1 	&	213	&	1814	&	1921	&	341006	&	322118	\\
	& \multirow{2}{*}{\texttt{DIST}}
  	& -	  & 180	& 2027  & 1741 & 481233	&	370617	\\
	& & 1 	&	213	&	1814	&	1921	&	429113	&	408744	\\
	& \multirow{2}{*}{\texttt{MD}}
  	& -	  & 180	& 2027  & 1741 & 294829	&	223494	\\
	& & 1 	&	213	&	1814	&	1921	&	250865	&	252787	\\
	& \multirow{2}{*}{\texttt{MIX}}
  	& -	  & 180	& 2027  & 1741 & 287343	&	238666	\\
	& & 1 	&	213	&	1814	&	1921	&	247304	&	253784	\\
\hline
\multirow{8}{*}{bcsstk17.rb}
	& \multirow{2}{*}{\texttt{-}}
  	& -	& 138	& 4366  & 6470  &  428589	&	853932	\\
	& & 5	&	336	&	5230	&	5408	&	586863	&	605433	\\
	& \multirow{2}{*}{\texttt{DIST}}
  	& -	& 138	& 4366  & 6470  & 493182	&	1302456	\\
	& & 4	&	378	&	5566	&	5030	&	841620	&	776253	\\
	& \multirow{2}{*}{\texttt{MD}}
  	& -	& 138	& 4366  & 6470  & 307119	&	749462	\\
	& & 4	&	378	&	5566	&	5030	&	416741	&	561724	\\
	& \multirow{2}{*}{\texttt{MIX}}
  	& -	& 138	& 4366  & 6470  & 313716	&	666343	\\
	& & 4	&	378	&	5566	&	5030	&	422073	&	482792	\\
\hline
\multirow{8}{*}{bcsstk18.rb}
	& \multirow{2}{*}{\texttt{-}}
    & -	& 182	& 6283  & 5483  & 1271033	&	640943	\\
	& & 2	&	504	&	5168	&	6276	&	762822	&	825365	\\
	& \multirow{2}{*}{\texttt{DIST}}
  	& -	& 182	& 6283  & 5483  & 1684137	&	864894	\\
	& & 2	&	504	&	5168	&	6276	&	1165838	&	1030540	\\
	& \multirow{2}{*}{\texttt{MD}}
  	& -	& 182	& 6283  & 5483  & 335191	&	172683	\\
	& & 2	&	504	&	5168	&	6276	&	209333	&	237071	\\
	& \multirow{2}{*}{\texttt{MIX}}
  	& -	& 182	& 6283  & 5483  & 346314	&	187524	\\
	& & 2	&	504	&	5168	&	6276	&	211226	&	242109	\\
\hline
\end{tabular}
\captionof{table}{Výsledky přesunu vrcholového separátoru pro nevyvážené matice. \label{mvsTable3}}
}
\bigskip

\label{mvswithNumbering}
Tento postup je vhodný pro vylepšování rozdělení bez používání číslování vrcholů. Pokud však číslujeme pouze v poslední iteraci hlavního cyklu, tj. spouštíme program bez argumentu \texttt{-oe}, může se stát, že část rozdělení s větším počtem nenulových prvků v Choleského faktoru bez použití číslování je jiná než část rozdělení s větším počtem nenulových prvků při použití číslování. V takovémto případě dochází k přesunu separátoru, který nám pomůže vyvážit počet nenulových prvků pro rozdělení bez číslování, ale naopak nám zhorší vyváženost pro očíslované grafy (viz například matice bcspwr07.rb v Tabulce \ref{mvsTable3}). Pro lepší výsledky v takovýchto případech je tedy vhodné číslovat v každé iteraci hlavní smyčky, což nám však výrazně přidá na výpočetní náročnosti. Záleží tedy na tom, jaký je problém, který se s pomocí Choleského faktorizace snažíme vyřešit a zda požadujeme co nejlepší vyvážení počtu operací na jednotlivých částech, nebo dáváme přednost rychlejšímu nalezení vhodného rozdělení. V tabulce \ref{oeArgumentTable} je uvedeno několik příkladů matic u kterých jsme tímto postupem dosáhli globálního zlepšení vyváženosti počtu nenulových prvků v Choleského faktorech oproti nejlepšímu předchozímu výsledku. Ve většině příkladů jsme však lepší rozdělení nezískali, lze tedy konstatovat, že pro obecné úlohy není třeba číslovat vrcholy podgrafů v každé iteraci.

\bigskip
{\noindent
\footnotesize
  \centering
  \renewcommand{\arraystretch}{1.15}
\begin{tabular}{|l|c|c|c|r|r|r|r|r|}
  \hline
  \multicolumn{1}{|c|}{Matice} & \multicolumn{1}{|c|}{\texttt{-oe}} & \multicolumn{1}{|c|}{\texttt{-ot}}  &\multicolumn{1}{|c|}{\texttt{-mvs}} &\multicolumn{1}{|c|}{$|S|$} & \multicolumn{1}{|c|}{$|V_1|$}& \multicolumn{1}{|c|}{$|V_2|$} & \multicolumn{2}{c|}{Počty nenul} \\
  \hline
  \multirow{2}{*}{1138\_bus.rb} 
  & -  &  \texttt{MD}   & 2  &	20	&	616	&	502	&	1011 &	860	\\
  & \cmark &  \texttt{MIX}  & 3  &	38	&	563	&	537	&	815	 &	934	\\
  \hline
  \multirow{2}{*}{bcspwr07.rb} 
  & -  &  \texttt{MD}   & 0 &	6	 &	843	&	763	&	1817	&	1716	\\
  & \cmark &  \texttt{MIX}  & 1 &	12	&	828	&	772	&	1763	&	1754	\\
  \hline
  \multirow{2}{*}{bcsstk17.rb} 
  & -  &  \texttt{MIX}  & 4 &	387	&	5566	&	5030	&	422073	&	482792	\\
  & \cmark &  \texttt{MIX}  & 5 &	417	&	5959	&	4598	&	467527	&	416845	\\
  \hline

\end{tabular}
\captionof{table}{Zlepšování vyvážení nenulových prvků v Choleského faktorech pomocí číslování v každé iteraci. \label{oeArgumentTable}}
}



%----------------------------------------------------------------------

\chapter*{Závěr}

V této práci jsme se zaměřili na analýzu problému paralelizace Choleského rozkladu pomocí dělení grafů. Popsali jsme základní pojmy týkající se grafů a problém dělení grafu. Zmínili jsme základní algoritmy pro dělení grafu s důrazem na víceúrovňové schéma dělení grafu. Dále jsme se zabývali rozklady matic, především úplným Choleského rozkladem. Popsali jsme souvislost mezi dělením grafu a Choleského rozkladem a zmínili, že základní kritéria nepokrývají vyváženost Choleského rozkladu. Zabývali jsme se číslováním vrcholů grafu jakožto nástrojem pro snížení počtu nenulových prvků v Choleského rozkladu a eliminačními stromy s jejichž pomocí lze efektivně zjistit počet nenulových prvků v Choleského faktoru matice. V praktické implementaci jsme se zaměřili na analýzu problému vyvážení počtu nenulových prvků v Choleského faktorech matic sousednosti jednotlivých podgrafů vzniklých rozdělením grafu odpovídajícího původní matici.

Z námi získaných výsledků vyplývá, že pro zvýšení efektivity Choleského rozkladu je zásadní, jak jsou řádky a sloupce vstupní matice permutovány. Tato permutace totiž přímo souvisí s očíslováním odpovídajícího grafu. Ukazuje se, že volbou správného očíslování můžeme snížit počet nenulových prvků až o jeden řád. Nejlépe se nám ověřilo očíslování vrcholů metodou minimálního stupně a očíslování podle smíšeného kritéria minimálního stupně a vzdálenosti vrcholu od separátoru. Tato dvě očíslování dávají řádově stejné výsledky. Naproti tomu očíslování podle vzdálenosti od separátoru a konvexní kombinace očíslování podle vzdálenosti od separátoru a očíslování získaného metodou minimálního stupně se ukázala jako nevhodná.

Další možností, jak zlepšit vyváženost rozdělení grafu vzhledem k počtu nenulových prvků v Choleského faktoru matice, je modifikovat samotné rozdělení. Námi navržená metoda přesunu vrcholového separátoru toto potvrdila, k vyvážení počtu nenulových prvků dochází již po několika málo modifikacích vektorového separátoru. Pozorovaná zvětšení velikosti vektorového separátoru nebyla ve většině případů dostatečně výrazná na to, aby převážila výhody získané přesunem separátoru.

Mohlo by se zdát, že z časového hlediska není výhodné zabývat se tímto způsobem paralelizace, není tomu však tak. Choleského rozklad matice nemusí být potřebný pouze pro řešení jedné konkrétní úlohy, ale můžeme se setkat s případy, kdy řešíme více soustav rovnic s maticemi, které jsou si velice blízké nebo se jedná dokonce o tutéž matici \cite{dutu:10}. V takových případech se nám vyplatí paralelizovat Choleského rozklad, protože při použití vhodného očíslování vrcholů odpovídajícího grafu nám stačí v Choleského rozkladu matice přepočítávat pomocí sloupcového algoritmu popsaného výše pouze několik posledních \TODO{sloupců?} Choleského faktoru. 

Vzhledem k analytickému charakteru práce není naše implementace efektivní. Dalším logickým krokem by tedy bylo navrhnout a vytvořit program, který by námi získané výsledky byl schopen získat v lepším čase. Při implementaci takového programu by se dalo uvažovat i nad implementací očíslování založených na metodě minimálního stupně, ale rychlejších \cite{amdadu:96}, což již ale přesahuje nad rámec této práce.


%----------------------------------------------------------------------
\newpage
\bibliographystyle{plain}
\bibliography{diplomka}

\TODO{nemam citovane dva zdroje ze zadani - moka:01, poth:97}

\TODO{poladit citovani odkazu}

\end{document} 